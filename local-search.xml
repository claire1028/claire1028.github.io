<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>How to cache contentful to google storage bucket</title>
    <link href="/2021/09/01/contentful-gitlab/"/>
    <url>/2021/09/01/contentful-gitlab/</url>
    
    <content type="html"><![CDATA[<p>Recently our email </p><ol><li>need support custom for differernt partner</li><li>need adopt new master email template</li></ol><p>So we can create new email template by contentful(CMS), but also have some advantages and disadvantages:</p><ul><li><p>Pros:<br>No need FE developer to modify text or image in code.<br>Repo code will be much cleaner.<br>All email template will adopt the one style.</p></li><li><p>Cons:<br>If the contentful server down, and we connect the api with contentful directly, then our email service will down, so we need cache the contentful email template data in some place. which is google bucket storage.</p></li></ul><p>So then we need to resolve the contentful server problem, then we need cache the data from contentful, we find two solutions to cache the data.</p><ol><li>Contentful Webhook call Google Cloud function to generate template data files and upload to bucket.</li><li>Contentful Webhook trigger pipeline to generate template data files and upload to bucket.</li></ol><h5 id="Google-Cloud-Funtion"><a href="#Google-Cloud-Funtion" class="headerlink" title="Google Cloud Funtion"></a>Google Cloud Funtion</h5><ul><li><p>In google cloud function, if u want to generate temp files , u need to use <code>/tmp</code> folder or will not work, maybe appear no access to write files.</p></li><li><p>If u want local fetch bucket files from gcp, u need access ,  appear this error :  <code>Could not load the default credentials. Browse to https://cloud.google.com/docs/authentication/getting-started for more information.</code>, you need run command gcloud auth application-default login, if u don’t install gloud , pls install this sdk first <a href="https://cloud.google.com/sdk/install">https://cloud.google.com/sdk/install</a>.</p></li><li><p>In some place maybe u will meet cloud function <code>does not have storage.objects.create access to the Google Cloud Storage object.</code>, u need  add this service account to storage bucket admin in IAM.</p></li></ul><p>The gcloud access token <code>expire time is 1h</code>, cause contentful no provide a function to get gcloud access token dynamic. If we open the public invoke, then we will maybe receive DDOS attack.</p><p>So we change to <code>gitlab pipeline</code> to response contentful webhook.</p><ul><li>Pros: Support access token trigger.</li><li>Cons: trigger pipeline cost much time than google cloud function. </li></ul><h5 id="Gitlab-pipeline-setting"><a href="#Gitlab-pipeline-setting" class="headerlink" title="Gitlab pipeline setting"></a>Gitlab pipeline setting</h5><p>1，need to generate a trigger token, in gitlab setttings -&gt; CI/CD -&gt; Pipeline triggers<br><img src="/images/content-1.png"></p><p>2, Need copy this token to contentful webhook request body. like below<br><img src="/images/content-2.png"></p><p>3, If we want to trigger for different env,  we need to add a variable like <code>TRIGGER_EVENT: &quot;AUTO_SAVE || PUBLISHED&quot;</code>, then in the gitlab-ci.yml file, we can trigger stage conditional on TRIGGER_EVENT.</p><p>4, Then trigger pipeline like below.<br><img src="/images/content-3.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>contentful</tag>
      
      <tag>bucket</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在Gitlab pipeline中自动创建发布文档和并集成slack</title>
    <link href="/2021/07/18/gitlab-slack/"/>
    <url>/2021/07/18/gitlab-slack/</url>
    
    <content type="html"><![CDATA[<p>在发布流程中我们经常需要查看当前的release 是否包含了别人的修改，并且我们还需要通知QA当前的这次发布是否可以上线，如果每次都手动去查看code 的commit changes ，然后找到相应的 code owner，效率太低并且有时候会遗漏，所以我们需要在Pipeline 中增加自动创建发布的文档，其中包括当前这次发布中包含的所有的待上线的commit 和相应的owner，并通知到Slack channel 中通知QA和相应的开发。</p><p>那么如何自动生成发布文档呢，首先我们发现gitlab自己携带了wiki功能，所以我们需要先在设置中<code>enable wiki</code>，<br>Wiki Enable 了之后，需要在pipeline中去创建并生成，Gitlab 本身提供了一系列的API去上传相应的内容到wiki中，<br>当Wiki生成完之后，我们需要在Slack channel中通知大家，那么这时候需要用到Slack 的webhook url, 至于如何得到 slack 的webhook url，可以自行google下。</p><p>当解决思路都串起来之后，我们就需要实现相应的流程在pipeline中，</p><p>1，设置如下相应的变量在gitlab ci yaml 配置中</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">RELEASE_NOTE_PATH: <span class="hljs-string">&#x27;&#123;your project wiki url&#125;/-/wikis/&#x27;</span> <span class="hljs-regexp">//gi</span>tlab 项目wiki的url<br>SLACK_CHANNEL_NAME: <span class="hljs-string">&#x27;slack channel name&#x27;</span> <span class="hljs-regexp">//</span> 需要通知的channel名字<br>SLACK_WEBHOOK_URL: <span class="hljs-string">&#x27;&#x27;</span>  <br></code></pre></td></tr></table></figure><p>2, 设置创建发布的文档job stage</p><figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs dsconfig"><span class="hljs-string">stages</span>:<br>  - ...<br>  - <span class="hljs-built_in">create-release-note</span>    <br>- ...<br><br> // 实现<span class="hljs-built_in">create-release-note</span> <span class="hljs-string">stage</span><br><span class="hljs-built_in">create-release-note:</span><br>  <span class="hljs-string">stage</span>: <span class="hljs-built_in">create-release-note</span><br>  <span class="hljs-string">when</span>: <span class="hljs-string">manual</span><br>  <span class="hljs-string">allow_failure</span>: <span class="hljs-string">true</span><br>  <span class="hljs-string">script</span>: <br>    - <span class="hljs-string">apk</span> <span class="hljs-string">add</span> <span class="hljs-string">git</span> <span class="hljs-string">bash</span><br>    - <span class="hljs-string">export</span> <span class="hljs-string">NOTIFICATION_HEADER</span>=<span class="hljs-string">&quot;Release &#123;Your prject name&#125; &quot;</span>  // 标题可以自定义<br>    - <span class="hljs-string">export</span> <span class="hljs-string">NOTIFICATION_MSG</span>=<span class="hljs-string">&quot;- Release Note:\n$&#123;RELEASE_NOTE_PATH&#125;&quot;</span> // 消息可以自定义<br>    - <span class="hljs-string">file_url</span>=<span class="hljs-string">&quot;&#123;Your prject name&#125;-release_$&#123;CI_COMMIT_TAG&#125;&quot;</span> // 生成的文档的<span class="hljs-string">url</span><br>    - <span class="hljs-string">LAST_VERSION</span>=$(<span class="hljs-string">curl</span> -<span class="hljs-string">k</span> <span class="hljs-string">&#x27;Here need get your latest released version.json&#x27;</span> | <span class="hljs-string">grep</span> <span class="hljs-string">&#x27;version&#x27;</span> | <span class="hljs-string">sed</span> <span class="hljs-string">&#x27;s/[^0-9.]*//g&#x27;</span>)<br>    - ./<span class="hljs-string">scripts</span>/<span class="hljs-string">update-release-note-to-wiki</span>.<span class="hljs-string">sh</span> <span class="hljs-string">&quot;v$&#123;LAST_VERSION&#125;&quot;</span> <span class="hljs-string">&quot;Your prject name&quot;</span> <span class="hljs-string">&quot;Your project approver&quot;</span>  // 上传到<span class="hljs-string">wiki</span><br>    // 发送消息到<span class="hljs-string">slack</span> <span class="hljs-string">channel</span><br>    - ./<span class="hljs-string">scripts</span>/<span class="hljs-string">slack-notify</span>.<span class="hljs-string">sh</span> <span class="hljs-string">&quot;$&#123;SLACK_WEBHOOK_URL&#125;&quot;</span> <span class="hljs-string">&quot;$&#123;SLACK_CHANNEL_NAME&#125;&quot;</span> <span class="hljs-string">&quot;$CI_PIPELINE_URL&quot;</span> <span class="hljs-string">&quot;$NOTIFICATION_HEADER$CI_COMMIT_TAG:\n$NOTIFICATION_MSG$file_url&quot;</span><br><br></code></pre></td></tr></table></figure><p>3,  发送消息到slack channel，我们可以使用shell脚本来实现，代码如下：<br><img src="/images/gitlab-1.png"><br><img src="/images/gitlab-2.png"><br><img src="/images/gitlab-3.png"></p><p>4, 如何上传到gitlab wiki，我们也可以使用shell 脚本来实现，代码如下：<br>wiki content 可以自定义<br><img src="/images/gitlab-4.png"><br><img src="/images/gitlab-5.png"></p><p><img src="/images/gitlab-6.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Gitlab</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何在Mjml中创建自定义标签</title>
    <link href="/2021/05/15/mjml-cutom-tag/"/>
    <url>/2021/05/15/mjml-cutom-tag/</url>
    
    <content type="html"><![CDATA[<p>我们使用MJML标记语言来创建响应式的邮件模板， 而MJML和HTML一样提供一些标签和熟悉来组织模板的样式和结构，如<br><code>&lt;mj-body&gt;</code>， <code>&lt;mj-section&gt;</code>，<code>&lt;mj-column&gt;</code>， <code>&lt;mj-text&gt; </code>等， 那么如何创建自定义的MJML标签呢？</p><p>打开mjml github 源码，打开所有标签实现的源码，我们发现：<br><img src="/images/mjml-1.png"></p><p>所有的tag实现都继承了BodyComponent, 所以BodyComponent是基础类，我们自定义标签也只需在该类的基础上继承并扩展，<br>我们实现一个简单的<mj-example /> 并解释下一些可自定义的属性：</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">import</span> &#123; BodyComponent &#125; from <span class="hljs-string">&#x27;mjml-core&#x27;</span>;<br>export <span class="hljs-keyword">default</span> class MjExample extends BodyComponent &#123;<br>  <span class="hljs-keyword">static</span> dependencies = &#123;<br>    <span class="hljs-string">&#x27;mj-example&#x27;</span>: [],  <span class="hljs-comment">// 表示允许什么标签出现在mj-example标签里面</span><br>    <span class="hljs-string">&#x27;mj-wrapper&#x27;</span>: [<span class="hljs-string">&#x27;my-example&#x27;</span>], <span class="hljs-comment">// 表示该标签允许出现在哪个标签里面</span><br>    <span class="hljs-string">&#x27;mj-body&#x27;</span>: [<span class="hljs-string">&#x27;my-example&#x27;</span>],<br>    <span class="hljs-string">&#x27;mj-section&#x27;</span>: [<span class="hljs-string">&#x27;my-example&#x27;</span>],<br>  &#125;;<br>  <span class="hljs-keyword">static</span> allowedAttributes = &#123;<br>    <span class="hljs-string">&#x27;background-image&#x27;</span>: <span class="hljs-string">&#x27;string&#x27;</span>, <span class="hljs-comment">// 允许传进来的参数属性</span><br>  &#125;;<br>  <span class="hljs-keyword">static</span> defaultAttributes = &#123;<br>    <span class="hljs-string">&#x27;background-image&#x27;</span>: <span class="hljs-string">&#x27;https://via.placeholder.com/150x150&#x27;</span>, <span class="hljs-comment">// 如果参数没有传进来给的默认的属性值</span><br>  &#125;;<br>  componentHeadStyle = () =&gt; &#123; <span class="hljs-comment">// 自定义的样式</span><br>    <span class="hljs-keyword">return</span> `<br>       .my-banner &#123;<br>        padding: <span class="hljs-number">0</span>;<br>        <span class="hljs-built_in">background</span>-<span class="hljs-built_in">color</span>: #ffffff;<br>        <span class="hljs-built_in">background</span>-<span class="hljs-built_in">image</span>: url($&#123;<span class="hljs-keyword">this</span>.getAttribute(<span class="hljs-string">&#x27;background-image&#x27;</span>)&#125;);<br>        <span class="hljs-built_in">background</span>-<span class="hljs-built_in">size</span>: cover;<br>        <span class="hljs-built_in">background</span>-repeat: no-repeat;<br>        <span class="hljs-built_in">height</span>: <span class="hljs-number">150</span>px;<br>      &#125;<br>    `;<br>  &#125;;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.renderMJML(`<br>      &lt;mj-section padding=<span class="hljs-string">&quot;0&quot;</span>&gt;<br>        &lt;mj-<span class="hljs-built_in">text</span>  font-<span class="hljs-built_in">size</span>=<span class="hljs-string">&quot;24px&quot;</span> <span class="hljs-built_in">line</span>-<span class="hljs-built_in">height</span>=<span class="hljs-string">&quot;28px&quot;</span> font-weight=<span class="hljs-string">&quot;bold&quot;</span> <span class="hljs-built_in">color</span>=<span class="hljs-string">&quot;black&quot;</span>&gt;<br>          &#123;&#123;title&#125;&#125;<br>        &lt;/mj-<span class="hljs-built_in">text</span>&gt;<br>         &lt;mj-<span class="hljs-built_in">image</span> css-class=<span class="hljs-string">&quot;my-banner&quot;</span> padding=<span class="hljs-string">&quot;0&quot;</span>&gt;<br>      &lt;/mj-section&gt;<br>    `);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当该标签定义好之后，之后我们就可以在模板里使用它，如：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">&lt;mj-<span class="hljs-built_in">example</span> <span class="hljs-built_in">background</span>-<span class="hljs-built_in">image</span>=<span class="hljs-string">&quot;https://via.placeholder.com/250x250&quot;</span> /&gt; // 如果不用自定义图片，则可以不传<span class="hljs-built_in">background</span>-参数<br></code></pre></td></tr></table></figure><p>自定义好之后，当我们在创建template的时候如何能做到实时更新呢？答案是我们可以使用gulp watch然后build mjml 模板，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> gulp = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp&#x27;</span>);<br><span class="hljs-keyword">const</span> babel = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-babel&#x27;</span>);<br><span class="hljs-keyword">const</span> watch = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;gulp-watch&#x27;</span>);<br><span class="hljs-keyword">const</span> fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><br><span class="hljs-keyword">const</span> mjml2html = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mjml&#x27;</span>);<br><span class="hljs-keyword">const</span> &#123; registerComponent &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;mjml-core&#x27;</span>);<br><span class="hljs-keyword">const</span> glob = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;glob&#x27;</span>);<br><span class="hljs-keyword">const</span> fsPath = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs-path&#x27;</span>);<br><span class="hljs-keyword">const</span> componentPath = path.normalize(<span class="hljs-string">&#x27;comp/**/*.ts&#x27;</span>); <span class="hljs-comment">// 自定义标签的组件路径</span><br><span class="hljs-keyword">const</span> templatePath = <span class="hljs-string">&#x27;tmpl/**/*.mjml&#x27;</span>; <span class="hljs-comment">// 邮件模板路径</span><br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">handleError</span>(<span class="hljs-params">err</span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(err.toString());<br>  process.exit(-<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-keyword">const</span> walkSync = <span class="hljs-function">(<span class="hljs-params">dir, filelist = []</span>) =&gt;</span> &#123;<br>  fs.readdirSync(dir).forEach(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> &#123;<br>    filelist = fs.statSync(path.join(dir, file)).isDirectory()<br>      ? walkSync(path.join(dir, file), filelist)<br>      : filelist.concat(path.join(dir, file));<br>  &#125;);<br>  <span class="hljs-keyword">return</span> filelist;<br>&#125;;<br><br><span class="hljs-keyword">const</span> watchedComponents = walkSync(<span class="hljs-string">&#x27;./comp&#x27;</span>); <span class="hljs-comment">// 自定义标签的组件路径</span><br><br><span class="hljs-keyword">const</span> compile = <span class="hljs-function">() =&gt;</span><br>  gulp<br>    .src(componentPath)<br>    .pipe(<br>      babel(&#123;<br>        <span class="hljs-attr">presets</span>: [<span class="hljs-string">&#x27;@babel/preset-env&#x27;</span>], <span class="hljs-comment">//这边添加babel parser</span><br>      &#125;)<br>    )<br>    .on(<span class="hljs-string">&#x27;error&#x27;</span>, handleError)<br>    .pipe(gulp.dest(<span class="hljs-string">&#x27;lib&#x27;</span>))<br>    .on(<span class="hljs-string">&#x27;end&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>      watchedComponents.forEach(<span class="hljs-function">(<span class="hljs-params">compPath</span>) =&gt;</span> &#123;<br>        <span class="hljs-comment">// 找到自定义tag的component并在全局注册</span><br>        <span class="hljs-keyword">const</span> distPath = compPath.substr(<span class="hljs-number">0</span>, compPath.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>)) + <span class="hljs-string">&#x27;.js&#x27;</span>; <br>        <span class="hljs-keyword">const</span> fullPath = path.join(process.cwd(), distPath.replace(<span class="hljs-regexp">/^comp/</span>, <span class="hljs-string">&#x27;lib&#x27;</span>));<br>        <span class="hljs-keyword">delete</span> <span class="hljs-built_in">require</span>.cache[fullPath];<br>        registerComponent(<span class="hljs-built_in">require</span>(fullPath).default);<br>      &#125;);<br>      glob(templatePath, <span class="hljs-function">(<span class="hljs-params">err, files</span>) =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">throw</span> err;<br>        files.forEach(<span class="hljs-function">(<span class="hljs-params">file</span>) =&gt;</span> &#123;<br>          <span class="hljs-keyword">const</span> templateName = file.split(<span class="hljs-string">&#x27;/&#x27;</span>)[<span class="hljs-number">2</span>];<br>          fs.readFile(file, <span class="hljs-string">&#x27;utf8&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">error, data</span>) =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (error) <span class="hljs-keyword">throw</span> error;<br>            <span class="hljs-keyword">const</span> result = mjml2html(data, &#123; <span class="hljs-attr">beautify</span>: <span class="hljs-literal">true</span> &#125;); <span class="hljs-comment">// 生成html</span><br>            fsPath.writeFileSync(path.normalize(<span class="hljs-string">`dist/<span class="hljs-subst">$&#123;templateName&#125;</span>.html`</span>), result.html);  <span class="hljs-comment">// 写入HTML文件</span><br>          &#125;);<br>        &#125;);<br>      &#125;);<br>    &#125;);<br>gulp.task(<span class="hljs-string">&#x27;build&#x27;</span>, compile);<br>gulp.task(<span class="hljs-string">&#x27;watch&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  compile();<br>  <span class="hljs-keyword">return</span> watch([componentPath, path.normalize(templatePath)], compile);<br>&#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Mjml</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何预防Graphql安全问题</title>
    <link href="/2021/03/18/graphql-security/"/>
    <url>/2021/03/18/graphql-security/</url>
    
    <content type="html"><![CDATA[<p>1，Auth验证<br>我们得根据header里的Authorization参数来验证改用户的session信息，同时将一些全局变量入userId, accountId 等存入context，而不是通过API 参数传入进来</p><p>2， 任何参数的输入验证<br>需严格对待每一个传进来的参数，如userId等，需验证这个信息是否和该用户的Authorization匹配</p><p>3，权限控制<br>如果系统有需做权限管理的时候，需验证任何一个操作该用户是否有正确的权限去更新和获取信息</p><p>3，Graphql 安全配置<br>ApolloServer在生产环境上以下配置需disable，防止代码信息泄露<br><code>introspection</code>,<br><code>playground</code>，<br><code>tracing</code>,<br><code>debug</code></p><p>限制验证配置</p><p>1，限制query的深度级数， 可采用插件 graphql-depth-limit， 避免内存被耗尽。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> depthLimit <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;graphql-depth-limit&#x27;</span><br><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span><br><span class="hljs-keyword">import</span> graphqlHTTP <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express-graphql&#x27;</span><br><span class="hljs-keyword">import</span> schema <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./schema&#x27;</span><br><br>const app = express()<br><br>app.use(<span class="hljs-string">&#x27;/graphql&#x27;</span>, graphqlHTTP(<span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> (&#123;<br>  schema,<br>  validationRules: [ depthLimit(<span class="hljs-number">10</span>) ]<br>&#125;)))<br></code></pre></td></tr></table></figure><p> 2，限制用户/客户端对query和mutation的请求频率， 如果公司已经对所有的api请求已经用了第三方公司对DDOS进行了保护，那么该插件可不用。<br> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> &#123; createRateLimitDirective &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;graphql-rate-limit&#x27;</span><br><span class="hljs-keyword">const</span> rateLimitDirective = createRateLimitDirective(&#123; <span class="hljs-attr">identifyContext</span>: <span class="hljs-function">(<span class="hljs-params">ctx</span>) =&gt;</span> ctx.id &#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> schema = &#123;<br>    typeDefs，<br>    resolvers,<br>    <span class="hljs-attr">schemaDirectives</span>: &#123;<br>    <span class="hljs-attr">rateLimit</span>: rateLimitDirective,<br>    &#125;,<br>&#125;<br></code></pre></td></tr></table></figure></p><p>3,  限制每个query参数的查询成本， 避免大量恶意的查询攻击</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> costAnalysis <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;graphql-cost-analysis&#x27;</span><br><span class="hljs-keyword">import</span> express <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express&#x27;</span><br><span class="hljs-keyword">import</span> graphqlHTTP <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;express-graphql&#x27;</span><br><span class="hljs-keyword">import</span> schema <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./schema&#x27;</span><br><br>const app = express()<br><br>app.use(<span class="hljs-string">&#x27;/graphql&#x27;</span>, graphqlHTTP(<span class="hljs-function"><span class="hljs-params">(req, res)</span> =&gt;</span> (&#123;<br>  schema,<br>  validationRules: [ <br>   costAnalysis(&#123;        variables: graphQLParams.variables,        maximumCost: <span class="hljs-number">1000</span>,      &#125;),<br>    ]<br>&#125;)))<br></code></pre></td></tr></table></figure><p>参考：<br><a href="https://cheatsheetseries.owasp.org/cheatsheets/GraphQL_Cheat_Sheet.html">https://cheatsheetseries.owasp.org/cheatsheets/GraphQL_Cheat_Sheet.html</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Graphql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rxjs源码分析(四)--Subject类</title>
    <link href="/2019/11/06/rxjs-subjects/"/>
    <url>/2019/11/06/rxjs-subjects/</url>
    
    <content type="html"><![CDATA[<p>Subject继承至Observable, 是一种特殊类型的Observable，支持同时输出值到多个订阅者，自己维护一个订阅者序列，就像是观察者模式。</p><span id="more"></span><p>下面我们看看源码：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 构造函数直接调用的Observable构造函数，本身并没有什么初始化内容</span><br><span class="hljs-keyword">constructor</span>() &#123;<br>  <span class="hljs-keyword">super</span>();<br>&#125;<br><br><span class="hljs-comment">// this.observers是订阅者队列，Subject对象调用next方法时，则将值传播给每个订阅者对象。</span><br><span class="hljs-comment">// 同理error，complete方法也是一样</span><br>next(value?: T) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.closed) &#123;<br>    <span class="hljs-keyword">throw</span> new ObjectUnsubscribedError();<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isStopped) &#123;<br>    <span class="hljs-keyword">const</span> &#123; observers &#125; = <span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">const</span> len = observers.length;<br>    <span class="hljs-keyword">const</span> copy = observers.slice();<br>    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>      copy[i].next(value);<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// Subject继承自Observable，当Subject对象调用Subscribe方法时，则通过原型链找到Observable上的方法Subscribe，而Subscribe方法</span><br><span class="hljs-comment">// 内部则调用了this._subscribe方法(具体可以看Observable类源码分析),</span><br><span class="hljs-comment">// 通过下面的方法，则将订阅者push到this.observers数组中。</span><br>_subscribe(subscriber: Subscriber&lt;T&gt;): Subscription &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.closed) &#123;<br>    <span class="hljs-keyword">throw</span> new ObjectUnsubscribedError();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasError) &#123;<br>    subscriber.error(<span class="hljs-keyword">this</span>.thrownError);<br>    <span class="hljs-keyword">return</span> Subscription.EMPTY;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isStopped) &#123;<br>    subscriber.complete();<br>    <span class="hljs-keyword">return</span> Subscription.EMPTY;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">this</span>.observers.push(subscriber);<br>    <span class="hljs-keyword">return</span> new SubjectSubscription(<span class="hljs-keyword">this</span>, subscriber);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>由于Subject自带next, error, complete等方法，则Subject对象可以作为参数传进Observable.subscribe方法中，<br>如：observable$.subscribe(new Subject());</p><p>Subject还有3中类型的传播值的方式，这三种都extends自Subject类</p><p><strong>1.BehaviorSubject</strong><br>储存最新的值，并将最新的值发给订阅者，一旦订阅者subscribe，则将会收到最新存储的值，下面我们看看源码</p><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-comment">// 构造函数中赋值了个内部变量_value保存当前的值</span><br>constructor(<span class="hljs-keyword">private</span> _value: T) &#123;<br>  <span class="hljs-keyword">super</span>();<br>&#125;<br><br><br>_subscribe(subscriber: Subscriber&lt;T&gt;): Subscription &#123;<br>  <span class="hljs-keyword">const</span> subscription = <span class="hljs-keyword">super</span>._subscribe(subscriber); <span class="hljs-comment">// 将当前subscriber加入到observers队列中</span><br>  <span class="hljs-keyword">if</span> (subscription &amp;&amp; !(&lt;SubscriptionLike&gt;subscription).closed) &#123;<br>    subscriber.<span class="hljs-keyword">next</span>(<span class="hljs-keyword">this</span>._value); <span class="hljs-comment">// 调用subscriber的next方法，并传入当前值</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> subscription;<br>&#125;<br><br><span class="hljs-keyword">next</span>(value: T): <span class="hljs-keyword">void</span> &#123;<br>  <span class="hljs-keyword">super</span>.<span class="hljs-keyword">next</span>(<span class="hljs-keyword">this</span>._value = value); 调用Subject的<span class="hljs-keyword">next</span>方法，将当前值多播<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>2.AsyncSubject</strong><br>当complete结束时，将Subject最后的值传给订阅者</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">_subscribe(subscriber: Subscriber&lt;any&gt;): Subscription &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasError) &#123;<br>    subscriber.error(<span class="hljs-keyword">this</span>.thrownError);<br>    <span class="hljs-keyword">return</span> Subscription.EMPTY;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasCompleted &amp;&amp; <span class="hljs-keyword">this</span>.hasNext) &#123;<br>    subscriber.next(<span class="hljs-keyword">this</span>.value); <span class="hljs-comment">//如果当前是已经结束的状态，则传值给订阅者</span><br>    subscriber.complete();<br>    <span class="hljs-keyword">return</span> Subscription.EMPTY;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>._subscribe(subscriber);<br>&#125;<br><br>next(value: T): void &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.hasCompleted) &#123; <span class="hljs-comment">// 当前如果没有结束，则将最新的值重新赋值</span><br>    <span class="hljs-keyword">this</span>.value = value; <br>    <span class="hljs-keyword">this</span>.hasNext = <span class="hljs-literal">true</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 调用该方法则执行结束，将hasCompleted变量至true，并将最新的值多播出去</span><br>complete(): void &#123;<br>  <span class="hljs-keyword">this</span>.hasCompleted = <span class="hljs-literal">true</span>; <br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasNext) &#123; <br>    <span class="hljs-keyword">super</span>.next(<span class="hljs-keyword">this</span>.value); <br>  &#125;<br>  <span class="hljs-keyword">super</span>.complete();<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>3.ReplaySubject</strong><br>主要功能是当订阅者subscribe时候，可以获取最新的几个值，多长时间之前的值<br>接受3个参数，第一个参数是获取几个最新的值，第二个参数是时间，用于多久之前的值可以被存储，第三个参数表示调度模式</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 初始化了bufferSize, windowTime，如果不传并赋默认值Number.POSITIVE_INFINITY，第三个参数表示调度模式</span><br><span class="hljs-keyword">constructor</span>(bufferSize: number = Number.POSITIVE_INFINITY,<br>            windowTime: number = Number.POSITIVE_INFINITY,<br>            <span class="hljs-keyword">private</span> scheduler?: SchedulerLike) &#123;<br>  <span class="hljs-keyword">super</span>();<br>  <span class="hljs-keyword">this</span>._bufferSize = bufferSize &lt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : bufferSize;<br>  <span class="hljs-keyword">this</span>._windowTime = windowTime &lt; <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : windowTime;<br><br>  <span class="hljs-keyword">if</span> (windowTime === Number.POSITIVE_INFINITY) &#123;<br>    <span class="hljs-keyword">this</span>._infiniteTimeWindow = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">this</span>.next = <span class="hljs-keyword">this</span>.nextInfiniteTimeWindow; <span class="hljs-comment">// 不同的时间分别对应不同的next方法</span><br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">this</span>.next = <span class="hljs-keyword">this</span>.nextTimeWindow;<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 如果时间参数不传则next方法为下面这个，主要为将value传进_events数组中，如果超过bufferSize，则shift一个最前面的值</span><br><span class="hljs-keyword">private</span> nextInfiniteTimeWindow(value: T): void &#123;<br>  <span class="hljs-keyword">const</span> _events = <span class="hljs-keyword">this</span>._events;<br>  _events.push(value);<br>  <span class="hljs-keyword">if</span> (_events.length &gt; <span class="hljs-keyword">this</span>._bufferSize) &#123;<br>    _events.shift();<br>  &#125;<br>  <span class="hljs-keyword">super</span>.next(value); <span class="hljs-comment">// 调用Subject的next方法将值多播出去</span><br>&#125;<br><br><span class="hljs-comment">// 如果时间参数有值则next方法为下面这个，这里面和上面的稍微有点不同，由于有了时间限制的概念，所以在存储每个值的时候也需要存储每个// 值的时间，所以通过ReplayEvent类来新建对象(包含time和value2个属性)，_trimBufferThenGetEvents方法下面看下</span><br><span class="hljs-keyword">private</span> nextTimeWindow(value: T): void &#123;<br>  <span class="hljs-keyword">this</span>._events.push(new ReplayEvent(<span class="hljs-keyword">this</span>._getNow(), value));<br>  <span class="hljs-keyword">this</span>._trimBufferThenGetEvents();<br>  <span class="hljs-keyword">super</span>.next(value); <span class="hljs-comment">// 调用Subject的next方法将值多播出去</span><br>&#125;<br><br><span class="hljs-comment">// 该方法主要通过当前的时间和参数传进的时间做对比，还有bufferSize的大小，来决定this._events里的结果</span><br><span class="hljs-keyword">private</span> _trimBufferThenGetEvents(): ReplayEvent&lt;T&gt;[] &#123;<br>  <span class="hljs-keyword">const</span> now = <span class="hljs-keyword">this</span>._getNow();<br>  <span class="hljs-keyword">const</span> _bufferSize = <span class="hljs-keyword">this</span>._bufferSize;<br>  <span class="hljs-keyword">const</span> _windowTime = <span class="hljs-keyword">this</span>._windowTime;<br>  <span class="hljs-keyword">const</span> _events = &lt;ReplayEvent&lt;T&gt;[]&gt;<span class="hljs-keyword">this</span>._events;<br><br>  <span class="hljs-keyword">const</span> eventsCount = _events.length;<br>  let spliceCount = <span class="hljs-number">0</span>;<br><br>  <span class="hljs-keyword">while</span> (spliceCount &lt; eventsCount) &#123;<br>    <span class="hljs-keyword">if</span> ((now - _events[spliceCount].time) &lt; _windowTime) &#123;<br>      <span class="hljs-keyword">break</span>;<br>    &#125;<br>    spliceCount++; <span class="hljs-comment">// 找出几个不在规定时间内的events</span><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (eventsCount &gt; _bufferSize) &#123;<br>    spliceCount = Math.max(spliceCount, eventsCount - _bufferSize); <br>    <span class="hljs-comment">// 通过比较不在规定时间内的数量和传进的bufferSize大小，决定最终删除几个events</span><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (spliceCount &gt; <span class="hljs-number">0</span>) &#123;<br>    _events.splice(<span class="hljs-number">0</span>, spliceCount); <span class="hljs-comment">// 删除不需要的events</span><br>  &#125;<br><br>  <span class="hljs-keyword">return</span> _events;<br>&#125;<br><br><span class="hljs-comment">// 看看ReplaySubject的subscribe方法</span><br>_subscribe(subscriber: Subscriber&lt;T&gt;): Subscription &#123;<br>  <span class="hljs-keyword">const</span> _infiniteTimeWindow = <span class="hljs-keyword">this</span>._infiniteTimeWindow;<br>  <span class="hljs-keyword">const</span> _events = _infiniteTimeWindow ? <span class="hljs-keyword">this</span>._events : <span class="hljs-keyword">this</span>._trimBufferThenGetEvents();<br>  <span class="hljs-comment">// 获取当前的_events, 不明白为何这边这样写，this._events === this._trimBufferThenGetEvents()的</span><br><br>  <span class="hljs-keyword">const</span> scheduler = <span class="hljs-keyword">this</span>.scheduler;<br>  <span class="hljs-keyword">const</span> len = _events.length;<br>  let subscription: Subscription;<br><br>   <span class="hljs-comment">// error或者销毁的情况处理</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.closed) &#123;<br>    <span class="hljs-keyword">throw</span> new ObjectUnsubscribedError();<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isStopped || <span class="hljs-keyword">this</span>.hasError) &#123;<br>    subscription = Subscription.EMPTY;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 添加subscriber到observers数组中</span><br>    <span class="hljs-keyword">this</span>.observers.push(subscriber);<br>    subscription = new SubjectSubscription(<span class="hljs-keyword">this</span>, subscriber); <span class="hljs-comment">// 创建将来被销毁的资源</span><br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (scheduler) &#123; <span class="hljs-comment">// scheduler是对方法的调度，用于何时执行</span><br>    subscriber.add(subscriber = new ObserveOnSubscriber&lt;T&gt;(subscriber, scheduler));<br>  &#125;<br><br>  <span class="hljs-comment">// 将当前的events里的值传给subscriber的next函数，获取最新的几个值</span><br>  <span class="hljs-keyword">if</span> (_infiniteTimeWindow) &#123;<br>    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; len &amp;&amp; !subscriber.closed; i++) &#123;<br>      subscriber.next(&lt;T&gt;_events[i]);<br>    &#125;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; len &amp;&amp; !subscriber.closed; i++) &#123;<br>      subscriber.next((&lt;ReplayEvent&lt;T&gt;&gt;_events[i]).value);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.hasError) &#123;<br>    subscriber.error(<span class="hljs-keyword">this</span>.thrownError);<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isStopped) &#123;<br>    subscriber.complete();<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> subscription;<br>&#125;<br></code></pre></td></tr></table></figure><p>Subject又提供了3种不同类型的subject，方便了在不同场合的应用，如Rxjs利用BehaviorSubject可以做成类似redux的状态管理，因为BehaviorSubject存储当前最新的值，并可以获取当前最新的值，且本身Rxjs就很适合异步应用，<a href="https://github.com/claire1028/React-Rxjs">简单的实现可以看这儿</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Rxjs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rxjs源码分析(三)--Subscription类</title>
    <link href="/2019/11/05/rxjs-Subscription/"/>
    <url>/2019/11/05/rxjs-Subscription/</url>
    
    <content type="html"><![CDATA[<p>Subscription类代表了Observable执行过的资源，可以被回收的，下面我们看看它的构造函数和主要的方法，</p><span id="more"></span><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">// 将传进来的参数赋值</span><br><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(unsubscribe?: ()</span> =&gt; <span class="hljs-title">void</span>) <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">  if (unsubscribe) &#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">    (&lt;any&gt; this)._unsubscribe = unsubscribe;</span></span><br><span class="hljs-comment"><span class="hljs-function">  &#125;</span></span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure><p>在Observable中的subscribe方法中，有个add方法将Observable的执行结果作为参数传进来，其add方法就是Subscription中的，如下：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">add</span>(teardown: TeardownLogic): <span class="hljs-keyword">Subscription</span> &#123;<br>  let <span class="hljs-keyword">subscription</span> = (&lt;<span class="hljs-keyword">Subscription</span>&gt;teardown);<br>  // 如果teardown参数为空，则返回一个新建的<span class="hljs-keyword">Subscription</span><br>  <span class="hljs-keyword">if</span> (!(&lt;<span class="hljs-keyword">any</span>&gt;teardown)) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">Subscription</span>.EMPTY;<br>  &#125;<br><br>  switch (typeof teardown) &#123;<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;function&#x27;</span>: // 是函数时，则将函数作为参数并创建新的<span class="hljs-keyword">Subscription</span><br>      <span class="hljs-keyword">subscription</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Subscription</span>(&lt;(() =&gt; <span class="hljs-type">void</span>)&gt;teardown);<br>    <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;object&#x27;</span>: // 是<span class="hljs-keyword">Object</span>类型时，主要是为了处理一些<span class="hljs-keyword">operator</span>的特殊情况<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">subscription</span> === this || <span class="hljs-keyword">subscription</span>.closed || typeof <span class="hljs-keyword">subscription</span>.unsubscribe !== <span class="hljs-string">&#x27;function&#x27;</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">subscription</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (this.closed) &#123;<br>        <span class="hljs-keyword">subscription</span>.unsubscribe();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">subscription</span>;<br>      &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">subscription</span> instanceof <span class="hljs-keyword">Subscription</span>)) &#123;<br>        const tmp = <span class="hljs-keyword">subscription</span>;<br>        <span class="hljs-keyword">subscription</span> = <span class="hljs-built_in">new</span> <span class="hljs-keyword">Subscription</span>();<br>        <span class="hljs-keyword">subscription</span>._subscriptions = [tmp];<br>      &#125;<br>      break;<br>    <span class="hljs-keyword">default</span>: &#123;<br>      throw <span class="hljs-built_in">new</span> Error(<span class="hljs-string">&#x27;unrecognized teardown &#x27;</span> + teardown + <span class="hljs-string">&#x27; added to Subscription.&#x27;</span>);<br>    &#125;<br>  &#125;<br><br>  // <span class="hljs-keyword">subscription</span>创建一个_parentOrParents指向父级(Subscriber实例)<br>  let &#123; _parentOrParents &#125; = <span class="hljs-keyword">subscription</span>;<br>  <span class="hljs-keyword">if</span> (_parentOrParents === <span class="hljs-keyword">null</span>) &#123;<br>    <span class="hljs-keyword">subscription</span>._parentOrParents = this;<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_parentOrParents instanceof <span class="hljs-keyword">Subscription</span>) &#123;<br>    <span class="hljs-keyword">if</span> (_parentOrParents === this) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">subscription</span>;<br>    &#125;<br>    <span class="hljs-keyword">subscription</span>._parentOrParents = [_parentOrParents, this];<br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_parentOrParents.indexOf(this) === <span class="hljs-number">-1</span>) &#123;<br>    _parentOrParents.push(this);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">subscription</span>;<br>  &#125;<br><br>  // <span class="hljs-keyword">add</span>方法可以添加child <span class="hljs-keyword">subscription</span><br>  const subscriptions = this._subscriptions;<br>  <span class="hljs-keyword">if</span> (subscriptions === <span class="hljs-keyword">null</span>) &#123;<br>    this._subscriptions = [<span class="hljs-keyword">subscription</span>];<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    subscriptions.push(<span class="hljs-keyword">subscription</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">subscription</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们看看Subscription的主要功能unsubscribe方法：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs typescript">unsubscribe(): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">let</span> errors: <span class="hljs-built_in">any</span>[];<br><br>  <span class="hljs-comment">// closed 表示是否已经已经执行过unsubscribe</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.closed) &#123;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// _subscriptions变量保存当前需要被销毁的资源，包含child subscription</span><br>  <span class="hljs-keyword">let</span> &#123; _parentOrParents, _unsubscribe, _subscriptions &#125; = (&lt;<span class="hljs-built_in">any</span>&gt; <span class="hljs-built_in">this</span>);<br><br>  <span class="hljs-built_in">this</span>.closed = <span class="hljs-literal">true</span>;<br>  <span class="hljs-comment">// 重置以防沿着原型链修改到上级的变量</span><br>  <span class="hljs-built_in">this</span>._parentOrParents = <span class="hljs-literal">null</span>;<br>  <span class="hljs-built_in">this</span>._subscriptions = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 从_parentOrParents对象中移除本次subscription中，</span><br>  <span class="hljs-comment">// remove函数(源码在下面)中移除_subscription数组中的某个元素，而_subscription就是父级上的_subscription，</span><br>  <span class="hljs-comment">// 之前this._subscriptions已经置null，这边再调用remove有意义？</span><br><br>  <span class="hljs-keyword">if</span> (_parentOrParents <span class="hljs-keyword">instanceof</span> Subscription) &#123;<br>    _parentOrParents.remove(<span class="hljs-built_in">this</span>);  <br>  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (_parentOrParents !== <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> index = <span class="hljs-number">0</span>; index &lt; _parentOrParents.length; ++index) &#123;<br>      <span class="hljs-keyword">const</span> parent = _parentOrParents[index];<br>      parent.remove(<span class="hljs-built_in">this</span>);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (isFunction(_unsubscribe)) &#123; <br>    <span class="hljs-comment">// 如果当前是通过new Subscription出来的待被销毁的函数，则call，表明当前Observable有返回待被unsubscribe函数</span><br>    <span class="hljs-keyword">try</span> &#123;<br>      _unsubscribe.call(<span class="hljs-built_in">this</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>      errors = e <span class="hljs-keyword">instanceof</span> UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e];<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 这边通过循环来执行subscription，包括当前的和添加的child级别的，</span><br>  <span class="hljs-keyword">if</span> (isArray(_subscriptions)) &#123;<br>    <span class="hljs-keyword">let</span> index = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> len = _subscriptions.length;<br><br>    <span class="hljs-keyword">while</span> (++index &lt; len) &#123;<br>      <span class="hljs-keyword">const</span> sub = _subscriptions[index];<br>      <span class="hljs-keyword">if</span> (isObject(sub)) &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>          sub.unsubscribe(); <span class="hljs-comment">// 回到当前函数来执行其中的child</span><br>        &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>          errors = errors || [];<br>          <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> UnsubscriptionError) &#123;<br>            errors = errors.concat(flattenUnsubscriptionErrors(e.errors));<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            errors.push(e);<br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (errors) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsubscriptionError(errors);<br>  &#125;<br>&#125;<br><br>remove(subscription: Subscription): <span class="hljs-built_in">void</span> &#123;<br>  <span class="hljs-keyword">const</span> subscriptions = <span class="hljs-built_in">this</span>._subscriptions;<br>  <span class="hljs-keyword">if</span> (subscriptions) &#123;<br>    <span class="hljs-keyword">const</span> subscriptionIndex = subscriptions.indexOf(subscription);<br>    <span class="hljs-keyword">if</span> (subscriptionIndex !== -<span class="hljs-number">1</span>) &#123;<br>      subscriptions.splice(subscriptionIndex, <span class="hljs-number">1</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Subscription通过add方法将可回收的资源添加，不管是空还是observable返回的函数，都可以通过Subscription回收，最后通过unsubscribe函数循环将可回收执行回收。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rxjs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rxjs源码分析(二)--Subscriber类</title>
    <link href="/2019/11/04/rxjs-Subscriber/"/>
    <url>/2019/11/04/rxjs-Subscriber/</url>
    
    <content type="html"><![CDATA[<p>前面我们分析了Observable类，大致了解了Observable类的执行时间以及如何执行的。<br>从Observable的Subscribe函数中，调用了函数toSubscriber返回Subscriber对象，我们看看该函数:</p><span id="more"></span><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> 如何参数提供的是Subscriber对象，则返回该对象，<br><span class="hljs-regexp">//</span> 否则将next, error, complete参数传进Subscriber类中去创建新的对象。<br><br><span class="hljs-keyword">export</span> function toSubscriber&lt;T&gt;(<br>  nextOrObserver?: PartialObserver&lt;T&gt; | (<span class="hljs-function"><span class="hljs-params">(value: T)</span> =&gt;</span> <span class="hljs-keyword">void</span>),<br>  error?: <span class="hljs-function"><span class="hljs-params">(error: any)</span> =&gt;</span> <span class="hljs-keyword">void</span>,<br>  complete?: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">void</span>): Subscriber&lt;T&gt; &#123;<br><br>  <span class="hljs-keyword">if</span> (nextOrObserver) &#123;<br>    <span class="hljs-keyword">if</span> (nextOrObserver <span class="hljs-keyword">instanceof</span> Subscriber) &#123;<br>      <span class="hljs-keyword">return</span> (&lt;Subscriber&lt;T&gt;&gt; nextOrObserver);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nextOrObserver[rxSubscriberSymbol]) &#123;<br>      <span class="hljs-keyword">return</span> nextOrObserver[rxSubscriberSymbol]();<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (!nextOrObserver &amp;&amp; !error &amp;&amp; !complete) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Subscriber(emptyObserver);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Subscriber(nextOrObserver, error, complete);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>看看Subscriber的构造函数</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">constructor(destinationOrNext?: PartialObserver&lt;any&gt; | (<span class="hljs-function"><span class="hljs-params">(value: T)</span> =&gt;</span> <span class="hljs-keyword">void</span>),<br>             error?: <span class="hljs-function"><span class="hljs-params">(e?: any)</span> =&gt;</span> <span class="hljs-keyword">void</span>,<br>             complete?: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">void</span>) &#123;<br>   <span class="hljs-built_in">super</span>(); <span class="hljs-regexp">//</span> 调用父类构造函数，继承至Subscription，从前面的类图可以看出<br><br>   <span class="hljs-keyword">switch</span> (<span class="hljs-built_in">arguments</span>.length) &#123;<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>      <span class="hljs-regexp">//</span> 不提供参数，则将emptyObserver赋值， empty是一个对象包含next,error,complete三个空函数，<br>      <span class="hljs-regexp">//</span> 和一个closed为<span class="hljs-literal">true</span>的bool变量<br>       <span class="hljs-built_in">this</span>.destination = emptyObserver;<br>       <span class="hljs-keyword">break</span>;<br><br>     <span class="hljs-regexp">//</span>下面代码的主要功能是： 给destination变量赋值， 如果参数提供的是<span class="hljs-built_in">Object</span> 则判断是否是Subscriber实例，是则赋值，否则将<span class="hljs-regexp">//</span> <span class="hljs-keyword">new</span> SafeSubscriber实例并赋值，所以destination变量也是Subscriber实例。SafeSubscriber类等下我们分析其作用<br>     <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>       <span class="hljs-keyword">if</span> (!destinationOrNext) &#123;<br>         <span class="hljs-built_in">this</span>.destination = emptyObserver;<br>         <span class="hljs-keyword">break</span>;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> destinationOrNext === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>         <span class="hljs-keyword">if</span> (destinationOrNext <span class="hljs-keyword">instanceof</span> Subscriber) &#123;<br>           <span class="hljs-built_in">this</span>.syncErrorThrowable = destinationOrNext.syncErrorThrowable;<br>           <span class="hljs-built_in">this</span>.destination = destinationOrNext;<br>           destinationOrNext.add(<span class="hljs-built_in">this</span>);<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>           <span class="hljs-built_in">this</span>.syncErrorThrowable = <span class="hljs-literal">true</span>;<br>           <span class="hljs-built_in">this</span>.destination = <span class="hljs-keyword">new</span> SafeSubscriber&lt;T&gt;(<span class="hljs-built_in">this</span>, &lt;PartialObserver&lt;any&gt;&gt; destinationOrNext);<br>         &#125;<br>         <span class="hljs-keyword">break</span>;<br>       &#125;<br>     default:<br>       <span class="hljs-built_in">this</span>.syncErrorThrowable = <span class="hljs-literal">true</span>;<br>       <span class="hljs-built_in">this</span>.destination = <span class="hljs-keyword">new</span> SafeSubscriber&lt;T&gt;(<span class="hljs-built_in">this</span>, &lt;(<span class="hljs-function"><span class="hljs-params">(value: T)</span> =&gt;</span> <span class="hljs-keyword">void</span>)&gt; destinationOrNext, error, complete);<br>       <span class="hljs-keyword">break</span>;<br>   &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>下面看看Subscriber中的next，error，complete方法，同时内部调用了_next, _error, _complete方法。<br>为何需要这么麻烦，还要再次定义_next，_error，_complete这三个内部使用的方法，应该是为了代码复用和功能内聚吧。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">  <span class="hljs-comment">// 这边isStopped变量是为了判断，如果当前已经调用了error，或者compete方法后，再次调用next是不起作用的，</span><br>  <span class="hljs-comment">// 所以需要该变量来作判断</span><br>next(value?: T): void &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isStopped) &#123;<br>    <span class="hljs-keyword">this</span>._next(value);<br>  &#125;<br>&#125;<br>error(err?: any): void &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isStopped) &#123;<br>    <span class="hljs-keyword">this</span>.isStopped = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">this</span>._error(err);<br>  &#125;<br>&#125;<br>complete(): void &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isStopped) &#123;<br>    <span class="hljs-keyword">this</span>.isStopped = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">this</span>._complete();<br>  &#125;<br>&#125;<br><br><span class="hljs-comment">// 源码采用的ts写的，protected关键字，作用是该方法仅能被该类和子类访问，具体可以看ts官网</span><br><span class="hljs-comment">// destination在构造函数中已经赋值，所以下面一般将执行到SafeSubscriber中</span><br><span class="hljs-keyword">protected</span> _next(value: T): void &#123;<br>  <span class="hljs-keyword">this</span>.destination.next(value);<br>&#125;<br><br><span class="hljs-keyword">protected</span> _error(err: any): void &#123;<br>  <span class="hljs-keyword">this</span>.destination.error(err);<br>  <span class="hljs-keyword">this</span>.unsubscribe();<br>&#125;<br><br><span class="hljs-keyword">protected</span> _complete(): void &#123;<br>  <span class="hljs-keyword">this</span>.destination.complete();<br>  <span class="hljs-keyword">this</span>.unsubscribe();<br>&#125;<br></code></pre></td></tr></table></figure><p>下面我们看看SafeSubscriber类，该类继承至Subscriber，先来看看构造函数：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-regexp">//</span> SafeSubscriber中同时保存赋值_parentSubscriber变量，该变量保存父类Subscriber的实例<br><br> constructor(private _parentSubscriber: Subscriber&lt;T&gt;,<br>              observerOrNext?: PartialObserver&lt;T&gt; | (<span class="hljs-function"><span class="hljs-params">(value: T)</span> =&gt;</span> <span class="hljs-keyword">void</span>),<br>              error?: <span class="hljs-function"><span class="hljs-params">(e?: any)</span> =&gt;</span> <span class="hljs-keyword">void</span>,<br>              complete?: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">void</span>) &#123;<br>    <span class="hljs-built_in">super</span>();<br><br>    let next: <span class="hljs-function">(<span class="hljs-params">(value: T)</span> =&gt;</span> <span class="hljs-keyword">void</span>);<br>    let context: any = <span class="hljs-built_in">this</span>;<br><br>    <span class="hljs-regexp">//</span> 如果observerOrNext是function，则将next赋值给<span class="hljs-built_in">this</span>._next<br>    <span class="hljs-keyword">if</span> (isFunction(observerOrNext)) &#123;<br><span class="hljs-function">      <span class="hljs-title">next</span> = <span class="hljs-params">(&lt;((value: T) =&gt; <span class="hljs-keyword">void</span>)&gt; observerOrNext)</span>;</span><br><span class="hljs-function">    &#125; <span class="hljs-title">else</span> <span class="hljs-title">if</span> <span class="hljs-params">(observerOrNext)</span> &#123;</span><br><span class="hljs-function"></span><br><span class="hljs-function">       // 如果<span class="hljs-title">observerOrNext</span>是对象，则分别将<span class="hljs-title">next</span>，<span class="hljs-title">error</span>，<span class="hljs-title">complete</span>三个属性方法赋值</span><br><span class="hljs-function">      <span class="hljs-title">next</span> = <span class="hljs-params">(&lt;PartialObserver&lt;T&gt;&gt; observerOrNext)</span>.<span class="hljs-title">next</span>;</span><br><span class="hljs-function">      <span class="hljs-title">error</span> = <span class="hljs-params">(&lt;PartialObserver&lt;T&gt;&gt; observerOrNext)</span>.<span class="hljs-title">error</span>;</span><br><span class="hljs-function">      <span class="hljs-title">complete</span> = <span class="hljs-params">(&lt;PartialObserver&lt;T&gt;&gt; observerOrNext)</span>.<span class="hljs-title">complete</span>;</span><br><span class="hljs-function"></span><br><span class="hljs-function">      <span class="hljs-title">if</span> <span class="hljs-params">(observerOrNext !== emptyObserver)</span> &#123;</span><br><span class="hljs-function">        <span class="hljs-title">context</span> = <span class="hljs-title">Object</span>.<span class="hljs-title">create</span><span class="hljs-params">(observerOrNext)</span>;  // 同时将<span class="hljs-title">context</span>对象的<span class="hljs-title">__proto__</span>指向该<span class="hljs-title">observerOrNext</span>对象</span><br><span class="hljs-function">        <span class="hljs-title">if</span> <span class="hljs-params">(isFunction(context.unsubscribe))</span> &#123;</span><br><span class="hljs-function">          <span class="hljs-title">this</span>.<span class="hljs-title">add</span><span class="hljs-params">(&lt;() =&gt; <span class="hljs-keyword">void</span>&gt; context.unsubscribe.bind(context))</span>;</span><br><span class="hljs-function">        &#125;</span><br><span class="hljs-function">        <span class="hljs-title">context</span>.<span class="hljs-title">unsubscribe</span> = <span class="hljs-title">this</span>.<span class="hljs-title">unsubscribe</span>.<span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-built_in">this</span>)</span>;</span><br><span class="hljs-function">      &#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function"></span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">_context</span> = <span class="hljs-title">context</span>;</span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">_next</span> = <span class="hljs-title">next</span>;</span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">_error</span> = <span class="hljs-title">error</span>;</span><br><span class="hljs-function">    <span class="hljs-title">this</span>.<span class="hljs-title">_complete</span> = <span class="hljs-title">complete</span>;</span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure><p>下面分析下SafeSubscriber中的next 和 __tryOrUnsub方法，error和complete方法主要功能就是throw error 和资源回收，具体代码就不分析了。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// 从Subscriber中protected _next方法中调用了destination.next方法，一般调用到这边，</span><br><br>next(value?: T): void &#123;<br>  <span class="hljs-comment">// isStopped是父类Subscriber中的变量， _next是在构造函数中赋值了</span><br>  <span class="hljs-comment">// 如果程序没有出错或者没有完成，并且_next有值，则将调用__tryOrUnsub方法。</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.isStopped &amp;&amp; <span class="hljs-keyword">this</span>._next) &#123;<br>    <span class="hljs-keyword">const</span> &#123; _parentSubscriber &#125; = <span class="hljs-keyword">this</span>;<br>    <span class="hljs-keyword">if</span> (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) &#123;<br>      <span class="hljs-keyword">this</span>.__tryOrUnsub(<span class="hljs-keyword">this</span>._next, value); <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.__tryOrSetError(_parentSubscriber, <span class="hljs-keyword">this</span>._next, value)) &#123;<br>      <span class="hljs-keyword">this</span>.unsubscribe();<br>    &#125;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">private</span> __tryOrUnsub(fn: Function, value?: any): void &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// fn则就是订阅者传进来的next方法，value就是Observable中产生的值，</span><br>    <span class="hljs-comment">// this._context,如果订阅者传进的参数是Object对象，则this.context的__proto__是该Object对象，</span><br>    <span class="hljs-comment">// 如果传进的参数是方法，则this._context则是该SafeSubscriber对象</span><br>    fn.call(<span class="hljs-keyword">this</span>._context, value);<br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-comment">// error 处理</span><br>    <span class="hljs-keyword">this</span>.unsubscribe();<br>    <span class="hljs-keyword">if</span> (config.useDeprecatedSynchronousErrorHandling) &#123;<br>      <span class="hljs-keyword">throw</span> err;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      hostReportError(err);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从以上分析可以看出，Subscriber负责接收参数和转换，并统一对外接口和决定当前程序是否结束，真正执行的订阅者的函数是在SafeSubscriber类中。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rxjs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rxjs源码分析(一)--Observable类</title>
    <link href="/2019/11/03/rxjs-Observable/"/>
    <url>/2019/11/03/rxjs-Observable/</url>
    
    <content type="html"><![CDATA[<p>Observable类中主要方法分析，一般从最简单的创建Observable，并订阅相应的Observable的例子开始分析整个Observable的大概流程，</p><span id="more"></span><p>如例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> o$ = <span class="hljs-keyword">new</span> Observable(<span class="hljs-function"><span class="hljs-params">subscriber</span> =&gt;</span> &#123;<br>  subscriber.next(<span class="hljs-number">1</span>);<br>  subscriber.next(<span class="hljs-number">2</span>);<br>&#125;);<br><br><span class="hljs-keyword">const</span> o$.subscribe(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(x));<br><br></code></pre></td></tr></table></figure><p>下面开始看源码：</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-comment">// Observable 构造函数</span><br><br><span class="hljs-function"><span class="hljs-keyword">constructor</span><span class="hljs-params">(subscribe?: (this: Observable&lt;T&gt;, subscriber: Subscriber&lt;T&gt;)</span> =&gt; <span class="hljs-title">TeardownLogic</span>) <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">    if (subscribe) &#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">      this._subscribe = subscribe;</span></span><br><span class="hljs-comment"><span class="hljs-function">    &#125;</span></span><br><span class="hljs-function">    <span class="hljs-comment">// 只有一个参数subscribe，如果有参数就赋值给内部变量_subscribe</span></span><br><span class="hljs-function">  &#125;</span><br><span class="hljs-function">  <span class="hljs-comment">// 提供create静态函数create，创建新的observable</span></span><br><span class="hljs-function">   <span class="hljs-title">static</span> <span class="hljs-title">create</span>:</span> <span class="hljs-function"><span class="hljs-keyword">Function</span> = &lt;<span class="hljs-title">T</span>&gt;<span class="hljs-params">(subscribe?: (subscriber: Subscriber&lt;T&gt;)</span> =&gt; <span class="hljs-title">TeardownLogic</span>) =&gt; <span class="hljs-comment">&#123;</span></span><br><span class="hljs-comment"><span class="hljs-function">        return new Observable&lt;T&gt;(subscribe);</span></span><br><span class="hljs-comment"><span class="hljs-function">  &#125;</span></span><br></code></pre></td></tr></table></figure><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// Observable中的subscribe函数</span><br><br>subscribe(observerOrNext?: PartialObserver&lt;T&gt; | ((value: T) =&gt; <span class="hljs-keyword">void</span>),<br>            error?: (error: any) =&gt; <span class="hljs-keyword">void</span>,<br>            complete?: () =&gt; <span class="hljs-keyword">void</span>): Subscription &#123;<br><br>    <span class="hljs-keyword">const</span> &#123; <span class="hljs-keyword">operator</span> &#125; = <span class="hljs-keyword">this</span>; <span class="hljs-comment">// operator 表示pipe中的操作符，后面会细看</span><br>    <span class="hljs-keyword">const</span> sink = toSubscriber(observerOrNext, error, complete); <span class="hljs-comment">//将当前传进来的参数转变成Subscriber对象</span><br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">operator</span>) &#123;<br>      sink.add(<span class="hljs-keyword">operator</span>.call(sink, <span class="hljs-keyword">this</span>.source)); <span class="hljs-comment">//Subscriber对象继承自Subscription，所以具有add方法</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      sink.add(<br>        <span class="hljs-keyword">this</span>.source || (config.useDeprecatedSynchronousErrorHandling &amp;&amp; !sink.syncErrorThrowable) ?<br>        <span class="hljs-keyword">this</span>._subscribe(sink) :<br>        <span class="hljs-keyword">this</span>._trySubscribe(sink)<br>      );<br>      <span class="hljs-comment">//add方法的作用是将Observable资源执行的结果添加到即将被销毁的队列中，后面我们可以再细看add</span><br>      <span class="hljs-comment">// 这边不管三目运算符是true还是false，最终都会执行this._subscribe这个函数，即在创建Observable</span><br>      <span class="hljs-comment">// 时传进来的函数参数。那么下面类自带的_subscribe函数什么时候执行呢，当在pipe中传operator对</span><br>      <span class="hljs-comment">// observable进行操作时。</span><br>    &#125;<br>    <br>    <span class="hljs-comment">// 分析Observable的执行过程 ，对于error warning handle 我们可以先暂时忽略</span><br>    <span class="hljs-keyword">if</span> (config.useDeprecatedSynchronousErrorHandling) &#123;<br>      <span class="hljs-keyword">if</span> (sink.syncErrorThrowable) &#123;<br>        sink.syncErrorThrowable = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">if</span> (sink.syncErrorThrown) &#123;<br>          <span class="hljs-keyword">throw</span> sink.syncErrorValue;<br>        &#125;<br>      &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> sink;<br>  &#125;<br>  <br></code></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// Observable 提供的类内部调用的函数</span><br><br>_subscribe(subscriber: Subscriber&lt;any&gt;): TeardownLogic &#123;<br>  <span class="hljs-keyword">const</span> &#123; source &#125; = <span class="hljs-keyword">this</span>;<br>  <span class="hljs-keyword">return</span> source &amp;&amp; source.subscribe(subscriber);<br>&#125;<br><br>_trySubscribe(sink: Subscriber&lt;T&gt;): TeardownLogic &#123;<br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._subscribe(sink);<br>    <span class="hljs-comment">// 执行了Observable创建时传进来的函数参数，现在开始执行函数，同时将subscribe传进的</span><br>    <span class="hljs-comment">// next,error,complete转变成Subscriber对象作为参数传进来</span><br>  &#125; <span class="hljs-keyword">catch</span> (err) &#123;<br>    <span class="hljs-keyword">if</span> (config.useDeprecatedSynchronousErrorHandling) &#123;<br>      sink.syncErrorThrown = <span class="hljs-literal">true</span>;<br>      sink.syncErrorValue = err;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (canReportError(sink)) &#123;<br>      sink.error(err);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      console.warn(err);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>创建Observable的时候，函数并没有执行，只是将函数赋值给个变量，当订阅者开始订阅subscribe的时候才开始执行函数，所以Observable是惰性的，这个特性像函数一样，<br>同时订阅者也不关心什么时候返回值，我把参数callback传给你了，当你return值的时候，调用callback即可，和promise差不多，所以适合做异步运算。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Rxjs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Rxjs主要类图</title>
    <link href="/2019/11/02/rxjs-overview/"/>
    <url>/2019/11/02/rxjs-overview/</url>
    
    <content type="html"><![CDATA[<p>Rxjs主要类图和每个类中的方法如下，众所周知，下划线开头的方法是不建议对外使用的，源码中也注释标明了。</p><p><img src="/images/rxjs.jpg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Rxjs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React Vs Angular</title>
    <link href="/2019/03/20/react-angular/"/>
    <url>/2019/03/20/react-angular/</url>
    
    <content type="html"><![CDATA[<h3 id="1-从框架来看"><a href="#1-从框架来看" class="headerlink" title="1.从框架来看"></a>1.从框架来看</h3><p>Angular是MVC框架， 提供 HTTP服务，router， forms 等开箱即用的服务，所以灵活性没有React好<br>React仅是一个view 在mvc 框架中，所以Model 和Controller层可以由用户自己决定用什么，灵活性比angular好，常用的三方库有：react-router路由跳转，redux数据状态管理，enzyme单元测试。</p><h3 id="2-从体积大小来看"><a href="#2-从体积大小来看" class="headerlink" title="2.从体积大小来看"></a>2.从体积大小来看</h3><p>Angular包含的东西很多，所以体积要比React要大，自然加载速度要比React要慢。</p><h3 id="3-从DOM来看"><a href="#3-从DOM来看" class="headerlink" title="3.从DOM来看"></a>3.从DOM来看</h3><p>React采用了Virtual DOM, 即模拟了真实的HTML dom 结构和属性，而Angular采用了正常的DOM，所以在效率上React比Angular更好。</p><h3 id="4-从实现模板上来看"><a href="#4-从实现模板上来看" class="headerlink" title="4.从实现模板上来看"></a>4.从实现模板上来看</h3><p>React使用了JSX语法来实现展示的模板， 而jsx可以在JavaScript中写入并兼容js的语法，学习成本较低。<br>而Angular使用了HTML和自由的directives（如ng-if，ng-for）增加了学习的成本。</p><h3 id="5-组件化"><a href="#5-组件化" class="headerlink" title="5.组件化"></a>5.组件化</h3><p>React和angular 都具有组件化</p><h3 id="6-数据绑定方式"><a href="#6-数据绑定方式" class="headerlink" title="6.数据绑定方式"></a>6.数据绑定方式</h3><p>React是单向绑定，即：如果改变了state里的数据，则改变了UI上的数据，但是如果改变了UI上的数据，则不会改变State里的数据，这时需要用户自己去更改state里的数据。<br>Angular是双向绑定，即：如果改变UI上的数据，则直接改变了state里的数据，如果改变了State里的数据，则UI上的数据页会改变</p><h3 id="7-类型检查"><a href="#7-类型检查" class="headerlink" title="7.类型检查"></a>7.类型检查</h3><p>React使用JavaScript，动态类型语言，而Angular采用Typescript，静态类型类型检测，需事先声明类型。当然在React中也可以使用Typescript。</p><h3 id="8-移动端提供的解决方案"><a href="#8-移动端提供的解决方案" class="headerlink" title="8.移动端提供的解决方案"></a>8.移动端提供的解决方案</h3><p>Angular提供了Ionic，Ionic仅是一个钳在webview中的一个web应用。所以速度上还是比较慢。<br>React提供了React Native，React Native真正提供了一个原生的UI，所以速度上要比Ionic快很多</p><h3 id="9-学习曲线"><a href="#9-学习曲线" class="headerlink" title="9.学习曲线"></a>9.学习曲线</h3><p>React基本的需要学习JSX，state， props，生命周期，组件，同时还需要React-router， redux，这些基本就差不多了<br>Angular基本的需要学习指令，模块，装饰器，组件，服务，依赖注入，管道和模板，同时需要学习Rxjs，typescript等。<br>学习曲线Angular明显比React要高对于新手来说。</p><h3 id="10-React-fiber"><a href="#10-React-fiber" class="headerlink" title="10.React fiber"></a>10.React fiber</h3><p>在React V16以后，React增加了FIber的概念，速度较之前更快。使用上是不会有任何感觉的，fiber的主要的目的就是将任务划分等级，拆分的更细，同时任务可以暂停和恢复，当来了更高级的任务（如用户鼠标的点击），则暂停当前的任务，去完成更高级的任务。这样反应速度上会让用户感觉更快！</p><p>参考：<a href="https://programmingwithmosh.com/react/react-vs-angular/">https://programmingwithmosh.com/react/react-vs-angular/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redux的applyMiddleware源码分析</title>
    <link href="/2019/02/20/redux/"/>
    <url>/2019/02/20/redux/</url>
    
    <content type="html"><![CDATA[<p>redux中dispatch只能是object对象，这对于同步的操作是可行的，但如果是异步的操作，那么将行不通，对此，redux提供了applyMiddleware来增强相应的disptch方法，同时将applyMiddleware返回的函数作为参数传入createStore中，替换当前store中的dispatch方法。<br>下面我们具体结合redux-thunk中间件来分析下dispatch增强的源码：</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// applyMiddleware源码</span><br><br>export <span class="hljs-keyword">default</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">applyMiddleware</span><span class="hljs-params">(<span class="hljs-rest_arg">...middlewares</span>)</span> </span>&#123;<br>  <span class="hljs-keyword">return</span> createStore =&gt; (...args) =&gt; &#123; <span class="hljs-comment">//传入createStore保证middleware只会在store上应用一次</span><br>    <span class="hljs-keyword">const</span> store = createStore(...args)<br>    let dispatch = () =&gt; &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<br>        `Dispatching <span class="hljs-keyword">while</span> constructing your middleware <span class="hljs-keyword">is</span> not allowed. ` +<br>          `Other middleware would not be applied to <span class="hljs-keyword">this</span> dispatch.`<br>      )<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> middlewareAPI = &#123;   <span class="hljs-comment">//将getState和dispatch传入middleware中</span><br>      getState: store.getState,<br>      dispatch: (...args) =&gt; dispatch(...args) <br>      <span class="hljs-comment">//这时dispatch是上述构造的方法，当dispatch被中间件改造后则dispatch为改造后的</span><br>    &#125;<br>    <span class="hljs-keyword">const</span> chain = middlewares.map(middleware =&gt; middleware(middlewareAPI))<br>    dispatch = compose(...chain)(store.dispatch) <br>    <span class="hljs-comment">// 将原先的store.dispatch作为参数next传入middleware中</span><br>    <span class="hljs-comment">// compose将多个function如a,b,c。compose(a,b,c)将返回(...args) =&gt; a(b(c(...args)))，</span><br>    <span class="hljs-comment">// 即dispatch action时， c函数作为b函数的next，b函数作为a函数的next，所以将依次执行函数a，b，c。</span><br>    <span class="hljs-comment">// dispatch被中间件改造了 </span><br>    <br>    <span class="hljs-keyword">return</span> &#123;<br>      ...store,<br>      dispatch<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> redux-thunk源码<br><br><span class="hljs-keyword">function</span> createThunkMiddleware(extraArgument) &#123;<br>  return (&#123; dispatch, getState &#125;) =&gt; <span class="hljs-keyword">next</span> =&gt; action =&gt; &#123;<br>    <span class="hljs-regexp">//</span><span class="hljs-keyword">next</span>是store上的dispatch方法<br>    <span class="hljs-keyword">if</span> (typeof action === <span class="hljs-string">&#x27;function&#x27;</span>) &#123; <br>      <span class="hljs-regexp">//</span>如果action返回的是<span class="hljs-keyword">function</span>则继续将dispatch方法往下传，直到action非<span class="hljs-keyword">function</span>类型<br>      return action(dispatch, getState, extraArgument);<br>    &#125;<br>    <span class="hljs-regexp">//</span>如果action为非<span class="hljs-keyword">function</span>类型，则调用store.dispatch方法<br>    return <span class="hljs-keyword">next</span>(action);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// createStore中的片段代码</span><br><br>export default <span class="hljs-keyword">function</span> create<span class="hljs-constructor">Store(<span class="hljs-params">reducer</span>, <span class="hljs-params">preloadedState</span>, <span class="hljs-params">enhancer</span>)</span> &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">  ...</span><br><span class="hljs-operator">  </span><span class="hljs-keyword">if</span> (typeof enhancer !== &#x27;undefined&#x27;) &#123;<br>    <span class="hljs-keyword">if</span> (typeof enhancer !== &#x27;<span class="hljs-keyword">function</span>&#x27;) &#123;<br>      throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">Error(&#x27;Expected <span class="hljs-params">the</span> <span class="hljs-params">enhancer</span> <span class="hljs-params">to</span> <span class="hljs-params">be</span> <span class="hljs-params">a</span> <span class="hljs-params">function</span>.&#x27;)</span><br>    &#125;<br>    <span class="hljs-comment">//将createStore和reducer，初始state传入applyMiddleware中创建store</span><br>    return enhancer(createStore)(reducer, preloadedState)<br>  &#125;<br>  ...<br></code></pre></td></tr></table></figure><p>通过applyMiddleware传入中间件增强了dispatch方法，并返回增强的dispatch和其他的createStore上的方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>webpack中的配置devtool简单分析</title>
    <link href="/2019/01/21/wp-devtool/"/>
    <url>/2019/01/21/wp-devtool/</url>
    
    <content type="html"><![CDATA[<p>对于devtool中的配置有十几种方式，搞不清楚到底该用哪种，于是对于每个配置都试着打包一遍，看看打包后的代码有何不同。</p><span id="more"></span><p>记录如下：</p><p>入口文件如下：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// print.js</span><br><span class="hljs-keyword">import</span> * as react from <span class="hljs-symbol">&#x27;reac</span>t&#x27;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">react</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt; <span class="hljs-type">This</span> is test! &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>webpack.config.js 配置文件如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> CleanWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>);<br><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/print.js&#x27;</span>,<br>  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;false&#x27;</span>,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> CleanWebpackPlugin([<span class="hljs-string">&#x27;dist&#x27;</span>]),<br>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;TEST&#x27;</span><br>    &#125;),<br>  ],<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span>,<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: path.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>  &#125;,<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.jsx?$/</span>,<br>        exclude: <span class="hljs-regexp">/(node_modules)/</span>,<br>        use:&#123;<br>            <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;babel-loader&#x27;</span><br>        &#125;,<br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>devtool的配置方式，大致分为如下4大类：</p><hr><p><strong>1：没有映射</strong></p><ul><li>devtool: false：一般用于production环境，没有sourcemap映射。</li></ul><hr><p><strong>2：eval方式的映射</strong></p><ul><li><p>eval：module代码被包括在eval中执行，且在末尾添加<code># sourceURL=...</code>，没有行映射，且代码是经过loader编译过的。</p></li><li><p>eval-source-map：尾部添加了<code>sourceMappingURL=...</code>。</p></li><li><p>cheap-eval-source-map：只有行对应，没有列对应，忽略loader的sourcemap，仅展示loader编译后的代码。</p></li><li><p>cheap-module-eval-source-map(<strong>推荐开发使用</strong>,初次build慢，但rebuild快): 没有列映射的 SourceMaps 文件，loader 的 sourcemap被简化为只包含对应行的。</p></li></ul><hr><p><strong>3：生成单独文件的映射</strong></p><ul><li><p>source-map：会单独生成相应的main.js.map文件。如：<br><img src="/images/devtool.png"></p></li><li><p>cheap-source-map：没有列的映射，忽略loader的sourcemap。</p></li><li><p>cheap-module-source-map：没有列映射的.map文件，且loader的sourcemap只包含对应行的。</p></li></ul><hr><p><strong>4：映射信息直接追加在对应文件末尾</strong></p><ul><li><p>inline-source-map： 将sourcemap信息追加到对应的文件末尾，会使得bundle文件变大。</p></li><li><p>inline-cheap-source-map：类似于cheap-source-map，但是map信息是添加在bundle中。</p></li><li><p>inline-cheap-module-source-map：类似于cheap-module-source-map，但是map信息是添加在bundle中。</p></li><li><p>hidden-source-map：和source-map 相比，文件末尾少了<code>//# sourceMappingURL=main.js.map</code>，作用于：不希望浏览器公开源代码映射。</p></li><li><p>nosources-source-map： 创建的main.js.map中没有sourceContent字段。</p></li></ul><hr><p>总的来说，如果配置中有<code>cheap</code>，则表示没有列映射同时没有loader的sourcemap(一般不能用于开发环境)，如果配置中有<code>module</code>，则表示有loader的sourcemap，所以开发环境中可以用<code>cheap-module</code>这种组合。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>如何简单创建一个webpack loader</title>
    <link href="/2019/01/15/loader/"/>
    <url>/2019/01/15/loader/</url>
    
    <content type="html"><![CDATA[<p>常言道授人以鱼不如授人以渔，当开发中某些loader满足不了我们特有的需求时，与其去网上搜罗，不如自己动手写个loader。</p><p>假如我们需实现这一个需求，对于html中的每个img标签，假设img标签中都没有alt属性（为了简单），统一给他们加上alt属性，并赋予相同的值，值由option配置。</p><p>为了实现该需求，首先创建<code>index.js</code> ， <code>index.html</code> ，<code>webpack.config.js</code>。</p><p>1.<code>index.js</code>比较简单，只需<code>import</code>引入<code>index.html</code>即可：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs aspectj"><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.html&#x27;</span>;<br></code></pre></td></tr></table></figure><p>2.index.html中，只需添加多个img 标签即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>This is a test page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;wrapper&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./123.png&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;./123.png&quot;</span> /&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3.webpack配置文件如下，webpack.config.js：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>);<br><span class="hljs-keyword">const</span> CleanWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;clean-webpack-plugin&#x27;</span>);<br><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;html-webpack-plugin&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = &#123;<br>  <span class="hljs-attr">entry</span>: <span class="hljs-string">&#x27;./src/index.js&#x27;</span>,<br>  <span class="hljs-attr">devtool</span>: <span class="hljs-string">&#x27;false&#x27;</span>,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> CleanWebpackPlugin([<span class="hljs-string">&#x27;dist&#x27;</span>]),<br>    <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;<br>      <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;Myself loader&#x27;</span><br>    &#125;)<br>  ],<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">chunkFilename</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span>,<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].js&#x27;</span>,<br>    <span class="hljs-attr">path</span>: path.resolve(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>  &#125;,<br>  <span class="hljs-attr">module</span>: &#123;<br>    <span class="hljs-attr">rules</span>: [<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.html$/</span>,<br>        use: [ <br>          &#123;<br>            <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;html-loader&#x27;</span>,<span class="hljs-comment">// 这边为何需要html-loader，后面解释</span><br>            <span class="hljs-attr">options</span>: &#123;<br>              <span class="hljs-attr">minimize</span>: <span class="hljs-literal">false</span><br>            &#125;<br>          &#125;,<br>          &#123;<br>            <span class="hljs-attr">loader</span>: path.resolve(__dirname, <span class="hljs-string">&#x27;./img-alt-loader/index.js&#x27;</span>),<br>            <span class="hljs-attr">options</span>: &#123;<br>              <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;this is img tag&#x27;</span><br>            &#125;<br>          &#125;<br>        ]<br>      &#125;,<br>      &#123;<br>        <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.(png|jpg|gif|jpeg|svg)$/</span>,<br>        use: &#123;<br>          <span class="hljs-attr">loader</span>: <span class="hljs-string">&#x27;url-loader&#x27;</span>,<br>          <span class="hljs-attr">options</span>: &#123;<br>            <span class="hljs-attr">limit</span>: <span class="hljs-number">1</span><br>          &#125;<br>        &#125;<br>      &#125;,<br>    ]<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure><p>下面开始创建loader，从上面webpack配置文件可以看出，我们在当前根目录下新建一个<code>img-alt-loader</code>文件夹，并在该文件夹下创建index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//index.js</span><br><span class="hljs-comment">// loader-utils 和 schema-utils 是在loader中常用的工具组件</span><br><span class="hljs-keyword">const</span> loaderUtils = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;loader-utils&#x27;</span>);<br><span class="hljs-keyword">const</span> validateOptions = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;schema-utils&#x27;</span>);<br><br><span class="hljs-keyword">const</span> attrParse = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./attributesParser&#x27;</span>);<br><span class="hljs-keyword">const</span> schema = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./option.json&#x27;</span>);<br><br><span class="hljs-built_in">module</span>.exports = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">loader</span>(<span class="hljs-params">content</span>) </span>&#123;<br>  <span class="hljs-built_in">this</span>.cacheable &amp;&amp; <span class="hljs-built_in">this</span>.cacheable();<br><br>  <span class="hljs-keyword">const</span> options = loaderUtils.getOptions(<span class="hljs-built_in">this</span>) || &#123;&#125;; <span class="hljs-comment">//获取option</span><br>  validateOptions(schema, options, <span class="hljs-string">&#x27;img alt loader&#x27;</span>); <span class="hljs-comment">// 验证option类型</span><br><br>  <span class="hljs-keyword">const</span> altTitle = options.title || <span class="hljs-string">&#x27;default img&#x27;</span>;<br>  <span class="hljs-keyword">const</span> attributes = [<span class="hljs-string">&#x27;img:src&#x27;</span>];<br><br>  <span class="hljs-keyword">const</span> links = attrParse(content, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tag, attr</span>) </span>&#123; <span class="hljs-comment">//解析html tag</span><br>    <span class="hljs-keyword">return</span> attributes.find(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">ar</span>) </span>&#123;<br>      <span class="hljs-keyword">return</span> (tag + <span class="hljs-string">&quot;:&quot;</span> + attr) === ar;<br>    &#125;);<br>  &#125;);<br><br>  links.reverse();<br>  content = [content];<br><br>  links.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">link</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> c = content.pop();<br>    content.push(c.substr(link.start + link.length + <span class="hljs-number">1</span>));<br>    content.push(<span class="hljs-string">` alt=&quot;<span class="hljs-subst">$&#123;altTitle&#125;</span>&quot;`</span>);<br>    content.push(c.substr(<span class="hljs-number">0</span>, link.start + link.length + <span class="hljs-number">1</span>));<br>  &#125;);<br><br>  content.reverse();<br>  content = content.join(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <br>  <span class="hljs-keyword">return</span> content; <br>  <span class="hljs-comment">//直接return了content，原因是我们把img-alt-loader并不作为最终的loader，即产生已经转换好的代码，所以直接返回content，</span><br>  <span class="hljs-comment">//如果我们把该loader作为最终的loader，那么这边的返回值，需得写成： return `module.exports=...`；</span><br>&#125;<br></code></pre></td></tr></table></figure><p>options.json 中只需check <code>title</code>类型是string</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs json"><span class="hljs-comment">//option.json</span><br>&#123;<br>  <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;object&quot;</span>,<br>  <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;title&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;string&quot;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs swift"><span class="hljs-comment">//attributesParser.js</span><br><span class="hljs-keyword">var</span> <span class="hljs-type">Parser</span> <span class="hljs-operator">=</span> require(<span class="hljs-string">&quot;fastparse&quot;</span>);<br><span class="hljs-keyword">var</span> processMatch <span class="hljs-operator">=</span> function(match, strUntilValue, name, value, index) &#123;<br>  <span class="hljs-keyword">if</span>(<span class="hljs-operator">!</span>this.isRelevantTagAttr(this.currentTag, name)) <span class="hljs-keyword">return</span>;<br>  this.results.push(&#123;<br>    start: index <span class="hljs-operator">+</span> strUntilValue.length,<br>    length: value.length,<br>    value: value<br>  &#125;);<br>&#125;;<br><br><span class="hljs-keyword">var</span> parser <span class="hljs-operator">=</span> new <span class="hljs-type">Parser</span>(&#123;<br>  outside: &#123;<br>    <span class="hljs-string">&quot;&lt;!--.*?--&gt;&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;&lt;![CDATA[.*?]]&gt;&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;&lt;[!<span class="hljs-subst">\\</span>?].*?&gt;&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;&lt;\/[^&gt;]+&gt;&quot;</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-string">&quot;&lt;([a-zA-Z<span class="hljs-subst">\\</span>-:]+)<span class="hljs-subst">\\</span>s*&quot;</span>: function(match, tagName) &#123;<br>      this.currentTag <span class="hljs-operator">=</span> tagName;<br>      <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;inside&quot;</span>;<br>    &#125;<br>  &#125;,<br>  inside: &#123;<br>    <span class="hljs-string">&quot;<span class="hljs-subst">\\</span>s+&quot;</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// eat up whitespace</span><br>    <span class="hljs-string">&quot;&gt;&quot;</span>: <span class="hljs-string">&quot;outside&quot;</span>, <span class="hljs-comment">// end of attributes</span><br>    <span class="hljs-string">&quot;(([0-9a-zA-Z<span class="hljs-subst">\\</span>-:]+)<span class="hljs-subst">\\</span>s*=<span class="hljs-subst">\\</span>s*<span class="hljs-subst">\&quot;</span>)([^<span class="hljs-subst">\&quot;</span>]*)<span class="hljs-subst">\&quot;</span>&quot;</span>: processMatch,<br>    <span class="hljs-string">&quot;(([0-9a-zA-Z<span class="hljs-subst">\\</span>-:]+)<span class="hljs-subst">\\</span>s*=<span class="hljs-subst">\\</span>s*<span class="hljs-subst">\&#x27;</span>)([^<span class="hljs-subst">\&#x27;</span>]*)<span class="hljs-subst">\&#x27;</span>&quot;</span>: processMatch,<br>    <span class="hljs-string">&quot;(([0-9a-zA-Z<span class="hljs-subst">\\</span>-:]+)<span class="hljs-subst">\\</span>s*=<span class="hljs-subst">\\</span>s*)([^<span class="hljs-subst">\\</span>s&gt;]+)&quot;</span>: processMatch<br>  &#125;<br>&#125;);<br><br>module.exports <span class="hljs-operator">=</span> function parse(html, isRelevantTagAttr) &#123;<br>  <span class="hljs-keyword">return</span> parser.parse(<span class="hljs-string">&quot;outside&quot;</span>, html, &#123;<br>    currentTag: null,<br>    results: [],<br>    isRelevantTagAttr: isRelevantTagAttr<br>  &#125;).results;<br>&#125;;<br></code></pre></td></tr></table></figure><p>目录结构如下：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">|-- project</span><br>    <span class="hljs-string">|-- src</span><br>        <span class="hljs-string">|-- index.js</span><br>        <span class="hljs-string">|-- index.html</span><br>    <span class="hljs-string">|-- img-alt-loader</span><br>        <span class="hljs-string">|-- index.js</span><br>        <span class="hljs-string">|-- option.json</span><br>        <span class="hljs-string">|-- attributesParser.js</span><br>    <span class="hljs-string">|-- webpack.config.js</span><br></code></pre></td></tr></table></figure><p>使用webpack 开发模式打包<code>--mode development</code>，可以看出如下结果，img标签上都添加了<code>alt=&quot;this is img tag&quot;</code> 属性。</p><p><img src="/images/loader.png"></p><p>由于nodejs是单线程操作的，所以对于某些异步操作，尽量把loader设为async loader，这样就不影响后续的操作并加快了打包速度。<br>img-alt-loader可能没有什么实际意义，但对于如何自己写loader提供了入门。O(∩_∩)O</p>]]></content>
    
    
    
    <tags>
      
      <tag>Webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JS中常用的编码格式</title>
    <link href="/2018/12/21/js-encode/"/>
    <url>/2018/12/21/js-encode/</url>
    
    <content type="html"><![CDATA[<p><strong>Unicode</strong>：规定将全球的语言纳入一个字符集，即每种语言中的每个字符都有一个唯一的编码，以便可以跨平台，跨系统，跨语言而不冲突，且不用安装特定的字符集来解释某个国家的语言。</p><p>而<code>UTF-8</code>和<code>UTF-16</code>和<code>UTF-32</code>则是对<code>Unicode</code>字符集的具体实现的方法。</p><p><strong>UTF-8</strong>: 在1-4个字节中变长表示，比如数字或字母采用1个字节表示，在node中，一般默认采用该方法。</p><p><img src="/images/encode1.png"></p><p><strong>UTF-16</strong>: 采用2字节或4字节变长表示。</p><p><img src="/images/encode2.png"></p><p><strong>UTF-32</strong>: 全部用4字节表示，不兼容<code>ASCII</code>编码，容易浪费空间。</p><p><strong>UCS-2</strong> ： JS里的编码表示，采用固定2个字节，后来被<code>UTF-16</code>取代了，也就是说<code>UTF-16</code>将<code>UCS-2</code>包含在其中。所以现在JS也就是采用<code>UTF-16</code>表示。</p><p>由于<code>UTF-16</code>一般是2个字节表示的，所以对于单字母，比如<code>&#39;a&#39; 0x61</code>只需占一个字节，那么是采取<code>[0x00,0x61]</code>还是<code>[0x61,0x00]</code>的表示表示呢，则设计到2种表示法，LE和BE，而对于<code>UTF-8</code>则没有这种顾虑.</p><ul><li><strong>UTF-16LE</strong>：<code>LE</code>是指<code>little endian</code>， 表示高地址放高位字节，a字符用LE表示则为<code>[0x61,0x00]</code></li><li><strong>UTF-16BE</strong>：<code>BE</code>是指<code>Big endian</code>， 表示低地址存放高位字节，符合我们平常的阅读习惯，用BE表示则为<code>[0x00, 0x61]</code></li></ul><p>那么在文件传输中如何表示该文件是什么编码格式呢？</p><p>使用<code>BOM(byte-order mark)</code>即字节顺序标记，表示该文件是LE还是BE，常被用来当做标示文件是以<code>UTF-8、UTF-16</code>或<code>UTF-32</code>编码的标记，在文件的开头会有如下编码标识：</p><ul><li><code>UTF-16</code>大端表示：<code>[0xFE, 0xFF]</code>，小端则是：<code>[0xFF, 0xFE]</code></li><li><code>UTF-32</code>大端表示：<code>[0x00 0x00 0xFE 0xFF]</code>，小端则是: <code>[0xFF 0xFE 0x00 0x00]</code></li><li>而在<code>UTF-8</code>里的表示则是：<code>[0xEF 0xBB 0xBF]</code>， 一般是用来标示该文件是<code>UTF-8</code>编码，而不用来说明字节顺序。</li></ul><p>汉字的长度在js中的长度是1，如 <code>&#39;好&#39;.length = 1;</code> 这里的1表示一个编码单元，而 <strong>不是占用的字节长度</strong> 。<br>如果想要计算字符串(含有汉字和字符)占的字节长度，可以用如下代码表示：</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCharBytes</span>(<span class="hljs-params">str</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> str.replace(<span class="hljs-regexp">/[^\u0000-\u00ff]/g</span>,<span class="hljs-string">&quot;aa&quot;</span>).length; <span class="hljs-comment">// 当字符unicode编码不在0000-00ff之间时，用两个字符替换，即占字节数2</span><br> &#125;<br></code></pre></td></tr></table></figure><p>但是有一些生僻字是用4个字节表示的，即超过了0xFFFF，比如：’𠮷’，<code>&#39;𠮷&#39;.length = 2;</code> 由于一个编码单元不能表示，所以需2个编码单元来表示，但是长度是2是错误的，在es5中是只能自己手动处理，但是在es6中我们可以使用<code>Array.from(&#39;𠮷&#39;).length</code> 来正确处理，输出1。</p><p>匹配所有字符是否都是汉字，如下所示：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">checkIsChinaChar</span>(char) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">/^[\u4e00-\u9fa5]+$/g.test(char)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>一些常用其他编码术语：</p><p><strong>ASCII</strong>: 一个字节，128位字母和数字表示。</p><p><strong>Base64</strong>：是一种基于64个可打印字符来表示二进制数据的表示方法</p><p><strong>Latin1</strong>: 单字节编码，向下兼容ASCII。</p><p><strong>GBK</strong>：汉字内码扩展的规范，兼容ASCII，不支持韩国字，如果程序只是面向汉字，可以采用该编码。</p><p><strong>Binary</strong>：二进制</p><p><strong>HEX</strong>: 十六进制</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jest + enzmye + ts测试react踩坑记</title>
    <link href="/2018/10/25/jest-enzyme/"/>
    <url>/2018/10/25/jest-enzyme/</url>
    
    <content type="html"><![CDATA[<p>如大家所知，react官方提供了<code>react-dom/test-utils</code>和r<code>react-test-renderer</code>来对react进行单元测试，而enzyme就是对他们的封装，更加便于开发者的使用。</p><p>那么在enzyme中<strong>shallow vs render vs mount</strong> 这3者有什么区别呢？</p><ul><li>shallow只会渲染一层元素，对于子组件是不渲染的。</li><li>如果需要测试组件生命周期，使用mount。</li><li>如果想测试渲染多层组件，但并不关心生命周期，使用render。<br>建议是尽量使用shallow， 性能会好点。</li></ul><h4 id="坑一："><a href="#坑一：" class="headerlink" title="坑一："></a>坑一：</h4><p>如果在component中用箭头函数定义function，也采取<code>jest.spyOn(Comp.prototype, &#39;overlayOnClick&#39;)</code>;</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade">overlayOnClick = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;;<br></code></pre></td></tr></table></figure><p>报错在原型上找不到该方法<br><img src="/images/jest1.png"></p><p>原因是经过ts转换后，箭头函数被转换成了实例上的方法，而非原型上的方法。</p><p>解决办法有：</p><ol><li><p>将<code>overlayOnClick function</code>改成在<code>construtor</code>中<code>bind</code>形式，不要使用箭头函数。</p></li><li><p>采用下面方法</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const instance = <span class="hljs-keyword">wrapper</span>.instance() <span class="hljs-keyword">as</span> <span class="hljs-keyword">any</span>;  // 不加这行会报错error TS2345 overlayOnClick 在<span class="hljs-keyword">wrapper</span>.instance上找不到相应的类型<br>const spy = jest.spyOn(instance, <span class="hljs-string">&#x27;overlayOnClick&#x27;</span>);<br>instance.forceUpdate(); //由于在spy之前已经mount，所以需forceUpdate<br><span class="hljs-keyword">wrapper</span>.find(<span class="hljs-string">&#x27;.overlay&#x27;</span>).simulate(<span class="hljs-string">&#x27;click&#x27;</span>, &#123;target: instance.overlay&#125;);<br>expect(spy).toHaveBeenCalledTimes(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li></ol><h4 id="坑二："><a href="#坑二：" class="headerlink" title="坑二："></a>坑二：</h4><p>需要测试这样一个case， 在<code>document.body</code>上面监听按键事件，一开始以为不过就是simulate中click事件换成相应的key事件，然而结果并非如此，测试失败，simulate并没有触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">  <span class="hljs-comment">// component</span><br><span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">document</span>.body.addEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-built_in">this</span>.onEsc, <span class="hljs-literal">false</span>);<br>&#125;<br><span class="hljs-function"><span class="hljs-title">componentWillUnmount</span>(<span class="hljs-params"></span>)</span> &#123;<br>  <span class="hljs-built_in">document</span>.body.removeEventListener(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-built_in">this</span>.onEsc, <span class="hljs-literal">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// test spec <br>const instance = <span class="hljs-keyword">wrapper</span>.instance() <span class="hljs-keyword">as</span> <span class="hljs-keyword">any</span>; <br>const spy = jest.spyOn(instance, <span class="hljs-string">&#x27;onEsc&#x27;</span>);<br>instance.forceUpdate();<br><span class="hljs-keyword">wrapper</span>.find(<span class="hljs-string">&#x27;.rc-dialog&#x27;</span>).simulate(<span class="hljs-string">&#x27;keyup&#x27;</span>, &#123;which: <span class="hljs-number">27</span>&#125;);<br>expect(spy).toHaveBeenCalledTimes(<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure><p>原来是由于document.body.addEventListener已经并非react中的事件了，而enzyme其实是对ReactTestUtils.Simulate的封装，所以自然不能处理非react的合成事件。<br>解决方法：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">const map = &#123;<br>    keyup: <span class="hljs-keyword">null</span><br>&#125;;<br>document.body.addEventListener = jest.fn((event, cb) =&gt; &#123;<br>    map[event] = cb;<br>&#125;);<br><br>const <span class="hljs-keyword">wrapper</span> = shallow(<br>    &lt;COMPONENT /&gt;<br>);<br>map.keyup(&#123;which: <span class="hljs-number">27</span>&#125;);<br></code></pre></td></tr></table></figure><h4 id="坑三："><a href="#坑三：" class="headerlink" title="坑三："></a>坑三：</h4><p>测试Hoc组件时，<code>mount</code> 或<code>shallow </code>返回的包装的组件实际上不是它所构造的构造函数的实例。返回的是高阶组件包着传进去的子组件。同时相应的prop也render在子组件上面，显示如下:<br> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">HWC</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">WrapperComp</span> <span class="hljs-attr">Loaded</span>=<span class="hljs-string">&#123;false&#125;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span><br>        wrpper comp<br>      <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">WrapperComp</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">HWC</span>&gt;</span><br></code></pre></td></tr></table></figure></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">// 高阶组件</span><br>export <span class="hljs-keyword">default</span> function <span class="hljs-type">HWC</span>(<span class="hljs-type">WrapComponent</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HC</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    state = &#123;<br>      loaded: <span class="hljs-literal">false</span><br>    &#125;;<br>    render() &#123;<br>      <span class="hljs-keyword">return</span> &lt;<span class="hljs-type">WrapComponent</span> &#123;...<span class="hljs-keyword">this</span>.state&#125; &#123;...<span class="hljs-keyword">this</span>.props&#125; /&gt;;<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// test spec<br><span class="hljs-keyword">class</span> WrapperComp extends React.Component &#123;<br>  render() &#123;<br>    <span class="hljs-keyword">return</span> &lt;h1&gt;wrpper comp&lt;/h1&gt;;<br>  &#125;<br>&#125;<br><br>const WrapperWithGt = HWC(WrapperComp);<br>describe(<span class="hljs-string">&#x27;test with hoc&#x27;</span>, () =&gt; &#123;<br>    beforeAll(() =&gt; &#123;<br>        <span class="hljs-keyword">wrapper</span> = mount(<br>          &lt;WrapperWithGt /&gt;<br>        );<br>    &#125;);<br>    it(<span class="hljs-string">&#x27;should wrapper with loaded prop&#x27;</span>, () =&gt; &#123;<br>        expect(<span class="hljs-keyword">wrapper</span>.find(<span class="hljs-string">&#x27;WrapperComp&#x27;</span>).props()).toHaveProperty(<span class="hljs-string">&#x27;loaded&#x27;</span>); <br>        // 这边如果换成h1元素，是无论如何也找不到loaded属性的<br>  &#125;);<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="坑四："><a href="#坑四：" class="headerlink" title="坑四："></a>坑四：</h4><p>在component中有这样一行语句，<code>location.reload();</code>报错如下，</p><p><img src="/images/jest2.png"></p><p>由于jsdom不支持导航，因此window.location.href或类似就会报错。可以对方法进行mock，解决如下：<br><code>window[&#39;location&#39;][&#39;reload&#39;] = jest.fn();</code></p><h4 id="坑五："><a href="#坑五：" class="headerlink" title="坑五："></a>坑五：</h4><p>当需要对window上的scroll事件进行监听测试时：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ScrollNav component</span><br><span class="hljs-comment">// ...</span><br><span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.debounceFunc = debounce(<span class="hljs-built_in">this</span>.getScrollAnchor, <span class="hljs-number">80</span>);<br>    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">&#x27;scroll&#x27;</span>, <span class="hljs-built_in">this</span>.debounceFunc, <span class="hljs-literal">false</span>);<br>  &#125;<br>getScrollAnchor = <span class="hljs-function">() =&gt;</span> &#123;<br>   <span class="hljs-comment">// ...</span><br>&#125;;<br><br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// test spec<br>const list = [<br>  &#123;<br>    anchor: <span class="hljs-string">&#x27;mockAnchor&#x27;</span>,<br>    title: <span class="hljs-string">&#x27;mock title1&#x27;</span>,<br>    onChangeAnchor: jest.fn()<br>  &#125;,<br>  &#123;<br>    anchor: <span class="hljs-string">&#x27;mockAnchor2&#x27;</span>,<br>    title: <span class="hljs-string">&#x27;mock title2&#x27;</span>,<br>    onChangeAnchor: jest.fn()<br>  &#125;<br>]; <br>describe(<span class="hljs-string">&#x27;scrollNav window scroll event&#x27;</span>, () =&gt; &#123;<br>    let <span class="hljs-keyword">wrapper</span> = <span class="hljs-keyword">null</span>;<br>    const map = &#123;<br>      scroll: <span class="hljs-keyword">null</span><br>    &#125;;<br><br>    beforeAll(() =&gt; &#123;<br>     const ele1 = document.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    const ele2 = document.createElement(<span class="hljs-string">&#x27;div&#x27;</span>);<br>    ele1.setAttribute(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;mockAnchor&#x27;</span>);<br>    ele2.setAttribute(<span class="hljs-string">&#x27;id&#x27;</span>, <span class="hljs-string">&#x27;mockAnchor2&#x27;</span>);<br>    document.body.appendChild(ele1);<br>    document.body.appendChild(ele2);<br>      <span class="hljs-keyword">window</span>.addEventListener = jest.fn((event, cb) =&gt; &#123;<br>        map[event] = cb;<br>      &#125;);<br><br>      <span class="hljs-keyword">wrapper</span> = shallow(<br>        &lt;ScrollNav <br>          lists=&#123;list&#125;<br>        /&gt;<br>      );<br>    &#125;);<br><br>    it(<span class="hljs-string">&#x27;should trigger scroll event&#x27;</span>, () =&gt; &#123;<br>       const instance = <span class="hljs-keyword">wrapper</span>.instance() <span class="hljs-keyword">as</span> <span class="hljs-keyword">any</span>;<br>       const spy = jest.spyOn(instance, <span class="hljs-string">&#x27;getScrollAnchor&#x27;</span>);<br>       instance.forceUpdate();<br>       map.scroll();<br>       jest.advanceTimersByTime(<span class="hljs-number">80</span>);<br>       expect(spy).toHaveBeenCalled();<br>    &#125;);<br>  &#125;) <br></code></pre></td></tr></table></figure><p>总是报错：</p><p><img src="/images/jest3.png"></p><p>没明白为何wrapper上的instance没被spy到？ 但是相应的state却是改变了。</p>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React中的Ref创建</title>
    <link href="/2018/09/25/react-ref/"/>
    <url>/2018/09/25/react-ref/</url>
    
    <content type="html"><![CDATA[<p><strong>1. ref用string 来表示</strong> ，React中已将它废弃, 原因有：</p><ul><li>静态类型检测不支持</li><li>无法混淆压缩</li><li>易产生挂载位置歧义</li><li>根组件无法使用</li></ul>  <span id="more"></span><p><strong>2.React.createRef()</strong></p><ul><li><p>当<code>React.createRef()</code>应用在html dom元素上的时候，dom元素赋值给<code>React.createRef().current</code>属性上。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-keyword">this</span>.rt = <span class="hljs-type">React</span>.createRef();<br>  &#125;<br>  componentDidMount() &#123;<br>    <span class="hljs-keyword">this</span>.rt.current.focus();<br>  &#125;<br>  render()&#123;<br>    <span class="hljs-keyword">return</span>(<br>      &lt;input ref=&#123;<span class="hljs-keyword">this</span>.rt&#125; /&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>当React.createRef()应用在class的Component上时，React.createRef().current上的值是Component的实例，所以不能将React.createRef()生成的值赋给Function Component，即无状态组件，因为他们没有实例。</p></li></ul> <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs scala"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-keyword">this</span>._ref = <span class="hljs-type">React</span>.createRef();<br>    <span class="hljs-keyword">this</span>.focusInput = <span class="hljs-keyword">this</span>.focusInput.bind(<span class="hljs-keyword">this</span>);<br>  &#125;<br><br>  focusInput() &#123;<br>    <span class="hljs-keyword">this</span>._ref.current.focus();<br>  &#125;;<br><br>  render() &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;input ref=&#123;<span class="hljs-keyword">this</span>._ref&#125; /&gt;<br>    )<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-keyword">this</span>.rt = <span class="hljs-type">React</span>.createRef();<br>  &#125;<br>  componentDidMount() &#123;<br>    <span class="hljs-keyword">this</span>.rt.current.focusInput();<br>  &#125;<br>  render()&#123;<br>    <span class="hljs-keyword">return</span>(<br>      &lt;<span class="hljs-type">Child</span> ref=&#123;<span class="hljs-keyword">this</span>.rt&#125; /&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3.React.forwardRef()</strong><br>通常我们对高阶组件添加ref属性，只能获取包裹的组件，而不能获取被包裹的组件，通过React.forwardRef()可以将ref属性从父组件传递到子组件中。<br>ref 是一个特殊的属性在react里，仅当使用React.forwardRef作为第二个参数时才存在，如果作为普通的函数和Component中作为props传递是不存在的。<br>使用场景有以下2种，一般使用于高阶组件传递ref。</p><ol><li>ref通过forwardRef直接传递到DOM node上 。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> FocusInput = React.forwardRef(<span class="hljs-function">(<span class="hljs-params">props, ref</span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;ref&#125;</span> /&gt;</span></span><br>&#125;);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span></span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(props);<br>    <span class="hljs-built_in">this</span>.ref = React.createRef();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">componentDidMount</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.ref.current.focus();<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">FocusInput</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&#123;this.ref&#125;</span> /&gt;</span></span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>在高阶组件中传递ref 到子组件中，得到子组件<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs scala">function wrapperWithChild(<span class="hljs-type">WrappedComponent</span>) &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    render() &#123;<br>      <span class="hljs-keyword">return</span>  &lt;<span class="hljs-type">WrappedComponent</span> ref=&#123;<span class="hljs-keyword">this</span>.props.innerRef&#125; /&gt;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">React</span>.forwardRef((props, ref) =&gt; &#123;<br>    <span class="hljs-keyword">return</span> &lt;<span class="hljs-type">Child</span> &#123;...props&#125; innerRef=&#123;ref&#125; /&gt;<br>  &#125;);<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  render()&#123;<br>    <span class="hljs-keyword">return</span> &lt;input className=<span class="hljs-symbol">&#x27;inpu</span>t&#x27; /&gt;;<br>  &#125;<br>&#125;<br><br>const <span class="hljs-type">Child</span> = wrapperWithChild(<span class="hljs-type">Wrap</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-keyword">this</span>.rt = <span class="hljs-type">React</span>.createRef();<br>  &#125;<br>  componentDidMount() &#123;<br>    console.log(<span class="hljs-keyword">this</span>.rt.current); <span class="hljs-comment">//这边this.rt.current得到的是Wrap组件</span><br>  &#125;<br>  render()&#123;<br>    <span class="hljs-keyword">return</span>(<br>      &lt;<span class="hljs-type">Child</span> ref=&#123;<span class="hljs-keyword">this</span>.rt&#125; /&gt; <br>    )<br>  &#125;<br>&#125;<br><span class="hljs-type">ReactDOM</span>.render(&lt;<span class="hljs-type">Parent</span> /&gt;, document.getElementById(<span class="hljs-symbol">&#x27;roo</span>t&#x27;));<br></code></pre></td></tr></table></figure></li></ol><p><strong>4.回调函数 Ref</strong></p><ul><li>直接作用在DOM元素上获取该元素<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-keyword">this</span>.rt = <span class="hljs-literal">null</span>;<br>  &#125;<br>  componentDidMount() &#123;<br>    <span class="hljs-keyword">this</span>.rt.focus();<br>  &#125;<br>  render()&#123;<br>    <span class="hljs-keyword">return</span>(<br>      &lt;input ref=&#123;ref =&gt; <span class="hljs-keyword">this</span>.rt = ref&#125; /&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li>可以通过像一个props 命名为任何字符除了ref 传递给其他组件，也可以在HOC中传递</li></ul><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  render()&#123;<br>    <span class="hljs-keyword">return</span> &lt;input ref=&#123;<span class="hljs-keyword">this</span>.props.innerRef&#125; /&gt;;<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-keyword">this</span>.rt = <span class="hljs-literal">null</span>;<br>  &#125;<br>  componentDidMount() &#123;<br>    <span class="hljs-keyword">this</span>.rt.focus();<br>  &#125;<br>  render()&#123;<br>    <span class="hljs-keyword">return</span>(<br>      &lt;<span class="hljs-type">Child</span> innerRef=&#123;ref =&gt; <span class="hljs-keyword">this</span>.rt = ref&#125; /&gt;<br>    )<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-comment">//高阶组件中传递使用例子</span><br>function wrapperWithChild(<span class="hljs-type">WrappedComponent</span>) &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Child</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>    render() &#123;<br>      <span class="hljs-keyword">return</span>  &lt;<span class="hljs-type">WrappedComponent</span> ref=&#123;<span class="hljs-keyword">this</span>.props.innerRef&#125; /&gt;<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">Child</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Wrap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  render()&#123;<br>    <span class="hljs-keyword">return</span> &lt;input className=<span class="hljs-symbol">&#x27;inpu</span>t&#x27; /&gt;;<br>  &#125;<br>&#125;<br><br>const <span class="hljs-type">Child</span> = wrapperWithChild(<span class="hljs-type">Wrap</span>);<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Parent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  constructor(props) &#123;<br>    <span class="hljs-keyword">super</span>(props);<br>    <span class="hljs-keyword">this</span>.rt = <span class="hljs-literal">null</span>;<br>  &#125;<br>  componentDidMount() &#123;<br>    console.log(<span class="hljs-keyword">this</span>.rt); <span class="hljs-comment">//这边this.rt得到的是Wrap组件</span><br>  &#125;<br>  render()&#123;<br>    <span class="hljs-keyword">return</span>(<br>      &lt;<span class="hljs-type">Child</span> innerRef=&#123;ref =&gt; <span class="hljs-keyword">this</span>.rt = ref&#125; /&gt; <br>    )<br>  &#125;<br>&#125;<br><span class="hljs-type">ReactDOM</span>.render(&lt;<span class="hljs-type">Parent</span> /&gt;, document.getElementById(<span class="hljs-symbol">&#x27;roo</span>t&#x27;));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node中子进程的创建和cluster原理</title>
    <link href="/2018/09/21/node-%E8%BF%9B%E7%A8%8B/"/>
    <url>/2018/09/21/node-%E8%BF%9B%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<p>node虽然是单进程单线程运行的，但是也提供创建子进程让程序运行的更加快速，稳健。创建方法如下：</p><span id="more"></span><h4 id="spawn："><a href="#spawn：" class="headerlink" title="spawn："></a>spawn：</h4><p>用法：<code>spawn(command[, args][, options])</code>，具体的参数请看官网。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> app.js<br>const &#123; spawn &#125; = require(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br>var sp1 = spawn(<span class="hljs-string">&#x27;node&#x27;</span>, [<span class="hljs-string">&#x27;test.js&#x27;</span>, <span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>,<span class="hljs-string">&#x27;three&#x27;</span>],&#123;stdio:[<span class="hljs-string">&#x27;pipe&#x27;</span>,<span class="hljs-string">&#x27;ipc&#x27;</span>, <span class="hljs-string">&#x27;ignore&#x27;</span>]&#125;);<br>var sp2 = spawn(<span class="hljs-string">&#x27;node&#x27;</span>,[<span class="hljs-string">&#x27;test1.js&#x27;</span>],&#123;stdio:[<span class="hljs-string">&#x27;pipe&#x27;</span>]&#125;);<br><br>sp1.on(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(data)&#123;<br>  console.log(<span class="hljs-string">&#x27;child out:&#x27;</span>+data);<br>  sp2.stdin.write(data);<br>&#125;);<br>sp1.on(<span class="hljs-string">&#x27;exit&#x27;</span>,<span class="hljs-keyword">function</span>(code, signal)&#123;<br>  console.log(<span class="hljs-string">&#x27;exit:&#x27;</span> +code);<br>  process.<span class="hljs-keyword">exit</span>();<br>&#125;);<br>sp1.on(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-keyword">function</span>(err)&#123;<br>  console.log(<span class="hljs-string">&#x27;error:&#x27;</span>+err);<br>  process.<span class="hljs-keyword">exit</span>();<br>&#125;);<br>sp1.on(<span class="hljs-string">&#x27;disconnect&#x27;</span>,<span class="hljs-keyword">function</span>()&#123;<br>  console.log(<span class="hljs-string">&#x27;ipc closed&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// test.js<br>process.send(<span class="hljs-string">&#x27;cwd:&#x27;</span>+ process.cwd());<br>process.argv.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">function</span>(val, <span class="hljs-keyword">index</span>)&#123;<br>   process.send(<span class="hljs-string">&#x27;\r\n&#x27;</span>+<span class="hljs-keyword">index</span>+<span class="hljs-string">&#x27;:&#x27;</span>+val);<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> test1.js<br><br>var fs = require(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>var out = fs.createWriteStream(<span class="hljs-string">&#x27;./space.txt&#x27;</span>);<br>process.stdin.on(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-keyword">function</span>(data)&#123;<br>  out.write(data);<br>&#125;);<br>process.stdin.on(<span class="hljs-string">&#x27;end&#x27;</span>,<span class="hljs-keyword">function</span>()&#123;<br>  process.<span class="hljs-keyword">exit</span>();<br>&#125;)<br></code></pre></td></tr></table></figure><p>这时直接运行：<br><img src="/images/node1.png"></p><p>发现test.js 中的data还没发送完成到父进程，程序就exit 了，查看官网exit事件，有一句解释 <strong>当 ‘exit’ 事件被触发时，子进程的 stdio 流可能依然是打开的</strong> 。也就是说，子进程一旦结束就触发exit事件，但是数据有可能还没传输完成，这样就解释的通了，<br>我们注释掉exit事件，再看看运行结果：</p><p><img src="/images/node2.png"></p><p>这样就运行正确了。</p><h4 id="fork"><a href="#fork" class="headerlink" title="fork:"></a>fork:</h4><p>用法：<code>fork(modulePath[, args][, options])</code><br><code>[options]silent</code>： false继承父进程的stdio，设置为true，子进程的stdin、stdout和stderr都会通过管道传递到父进程，否则他们将会从父进程继承。<br><code>[options]stdio</code>：[0,1,2,’ipc’], 如果要设置该属性值，则必须有个值为‘ipc’，否则报错。<br>该方法默认建立IPC通道</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// app.js</span><br><br><span class="hljs-keyword">const</span> &#123; fork &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br><span class="hljs-keyword">var</span> sp1 = fork(<span class="hljs-string">&#x27;test.js&#x27;</span>, [<span class="hljs-string">&#x27;one&#x27;</span>, <span class="hljs-string">&#x27;two&#x27;</span>,<span class="hljs-string">&#x27;three&#x27;</span>]);<br><span class="hljs-keyword">var</span> sp2 = fork(<span class="hljs-string">&#x27;test1.js&#x27;</span>,&#123;<span class="hljs-attr">silent</span>: <span class="hljs-literal">true</span>&#125;);<br><br>sp1.on(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;child out:&#x27;</span>+data);<br>  sp2.send(data);<br>&#125;);<br><br>sp2.stdout.on(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(data.toString() + <span class="hljs-string">&#x27;\r\n&#x27;</span>);<br>&#125;);<br><br>sp1.on(<span class="hljs-string">&#x27;error&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">err</span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;error:&#x27;</span>+err);<br>  process.exit();<br>&#125;);<br><br>sp1.on(<span class="hljs-string">&#x27;disconnect&#x27;</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;ipc closed&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">// test.js<br>process.send(<span class="hljs-string">&#x27;cwd:&#x27;</span>+ process.cwd());<br>process.argv.<span class="hljs-keyword">forEach</span>(<span class="hljs-keyword">function</span>(val, <span class="hljs-keyword">index</span>)&#123;<br>  console.log(<span class="hljs-string">&#x27;44444&#x27;</span>);<br>   process.send(<span class="hljs-string">&#x27;\r\n&#x27;</span>+<span class="hljs-keyword">index</span>+<span class="hljs-string">&#x27;:&#x27;</span>+val);<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-comment">// test1.js</span><br><span class="hljs-built_in">var</span> fs = <span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>);<br><span class="hljs-built_in">var</span> out = fs.createWriteStream(<span class="hljs-string">&#x27;./space.txt&#x27;</span>);<br><span class="hljs-built_in">var</span> i = <span class="hljs-number">0</span>;<br>process.<span class="hljs-keyword">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>,function(<span class="hljs-built_in">data</span>)&#123;<br>  console.<span class="hljs-keyword">log</span>(<span class="hljs-string">&#x27;xxx&#x27;</span>+ i);<br>  i++;<br>  out.write(<span class="hljs-built_in">data</span>);<br>&#125;);<br></code></pre></td></tr></table></figure><p>运行结果如下：<br><img src="/images/node3.png"></p><p>可以看到<code>silent：false</code>时，和父进程共享stdio，silent为true时，子进程的stdio事件被传递到父进程上，通过监听stdio上的data事件可获取子进程中的输出数据。输出的结果杂乱无序，可以看出多进程是各自运行的。</p><h4 id="exec"><a href="#exec" class="headerlink" title="exec:"></a>exec:</h4><p>用法：<code>exec(command[, options][, callback])</code><br><code>exec</code>通过命令生成一个shell来运行相关的子进程。和<code>spawn</code>的区别是<code>exec</code>子进程返回的<code>stdio</code>数据是同步的，而<code>spawn</code>是异步的。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> app.js<br>const &#123; exec &#125; = require(<span class="hljs-string">&#x27;child_process&#x27;</span>);<br>var sp1 = exec(<span class="hljs-string">&#x27;node test.js one two three&#x27;</span>,<span class="hljs-keyword">function</span>(err, stdout, stderr)&#123;<br>  <span class="hljs-keyword">if</span>(err) &#123;<br>    console.log(<span class="hljs-string">&#x27;error:&#x27;</span> + err);<br>    process.<span class="hljs-keyword">exit</span>();<br>  &#125;<span class="hljs-keyword">else</span> &#123;<br>    console.log(<span class="hljs-string">&#x27;child output:&#x27;</span>+stdout.toString());<br>    sp2.stdin.write(stdout.toString());<br>  &#125;<br><br>&#125;);<br>var sp2 = exec(<span class="hljs-string">&#x27;node test1.js&#x27;</span>,<span class="hljs-keyword">function</span>(err, stdout, stderr)&#123;<br>  process.<span class="hljs-keyword">exit</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lua">// test.js<br>process.<span class="hljs-built_in">stdout</span>.<span class="hljs-built_in">write</span>(<span class="hljs-string">&#x27;cwd:&#x27;</span>+ process.cwd());<br>process.argv.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(val, index)</span></span>&#123;<br>   process.<span class="hljs-built_in">stdout</span>.<span class="hljs-built_in">write</span>(<span class="hljs-string">&#x27;\r\n&#x27;</span>+index+<span class="hljs-string">&#x27;:&#x27;</span>+val);<br>&#125;)<br></code></pre></td></tr></table></figure><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> test1.js<br>var fs = require(<span class="hljs-string">&#x27;fs&#x27;</span>);<br>var out = fs.createWriteStream(<span class="hljs-string">&#x27;./space.txt&#x27;</span>);<br>process.stdin.on(<span class="hljs-string">&#x27;data&#x27;</span>,<span class="hljs-keyword">function</span>(data)&#123;<br>  out.write(data);<br>  process.<span class="hljs-keyword">exit</span>();<br>&#125;);<br></code></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/node4.png"></p><h4 id="execFile"><a href="#execFile" class="headerlink" title="execFile:"></a>execFile:</h4><p>用法：<code>execFile(file[, args][, options][, callback])</code><br>file参数是可执行的文件，在windows中如.bat文件。<br>和exec的区别是execFile直接通过可执行文件来生成子进程，相比exec稍微高效点。</p><p><strong>翻看源码exec是对execFile的封装，而execFile和fork底层都是调用的spawn。</strong></p><h3 id="cluster"><a href="#cluster" class="headerlink" title="cluster:"></a>cluster:</h3><p>node提供cluster模块充分利用多核cpu对子进程处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// app.js</span><br><span class="hljs-keyword">var</span> cluster = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;cluster&#x27;</span>);<br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">const</span> numCPUs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;os&#x27;</span>).cpus().length;<br><span class="hljs-keyword">if</span>(cluster.isMaster)&#123;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; numCPUs; i++) &#123;         <br>    cluster.fork();                           <br>  &#125;   <br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;run in main process&#x27;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  http.createServer(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>)</span>&#123;<br>    <span class="hljs-keyword">if</span>(req.url !== <span class="hljs-string">&#x27;/favicon.ico&#x27;</span>) &#123;<br>      res.writeHead(<span class="hljs-number">200</span>, &#123;<span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/html&#x27;</span>&#125;);<br>      res.write(<span class="hljs-string">&#x27;&lt;head&gt;&lt;meta charset=&quot;utf-8&quot;/&gt;&lt;/head&gt;&#x27;</span>);<br>      res.end(<span class="hljs-string">&#x27;hello\n&#x27;</span>);<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;run in child process&#x27;</span>);<br>    &#125;<br>  &#125;).listen(<span class="hljs-number">1337</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>运行node app, 先输出 run in main process, 然后打开浏览器localhost:1337,则会发现输出 run in child process.</p><p><img src="/images/node5.png"></p><p>对于操作系统中其实是不允许多个进程对同一个端口进行监听的，cluster生成子进程其实是利用的<code>child_process.fork()</code>，实现的原理其实是 <strong>利用主进程process.send方法中的第二个参数process.send(message [, sendHandle])将服务器对象或者socket对象传输给子进程，从而创建的子进程们都监听同一个socket端口对象。</strong></p>]]></content>
    
    
    
    <tags>
      
      <tag>node</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TS学习笔记</title>
    <link href="/2018/09/20/ts-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2018/09/20/ts-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<p>在学习ts过程中，接口和类傻傻分不清楚，记录如下：</p><p>类<code>implements</code>接口: 接口不提供实现，类进行实现，接口仅校验实例部分 </p><p>接口<code>extends</code> 接口：校验继承</p><p>接口<code>extends</code>类：接口继承了类，则该接口只能被这个类自己或类的子类所implements, 接口也可以作为变量类型检测</p><p>抽象类: abstract关键字修饰，不会被实例化，作为其他类的基类使用，定义的abstract方法必须在派生类中实现</p><p>类当作接口使用: 仅类的实例部分作类型检测</p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ul><li><strong>declare</strong>： 全局变量声明，或第三方定义的变量</li><li><strong>namespace</strong>：全局下的一个JS对象，若需通过namespace访问，则需要export</li><li><strong>module</strong>：<code>import * as abc from &#39;abc&#39;</code>, 当第三方库abc用js，而没有声明文件时，可以<code>declare  module &#39;abc&#39;</code>;</li></ul><p><strong>Q:既然<code>class</code>和<code>interface</code>都能用来做类型检测，那么<code>declare class</code> 和 <code>interface</code> 有什么区别呢？</strong></p><p>A:<code>declare class</code> 一般用在第三方库（用非ts实现）的声明文件中描述class中有哪些方法以及属性。而interface一般用在我们定义作类型检测</p><p>在学习过程中，使用tsc命令运行文件，总是报错，如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs css">// index<span class="hljs-selector-class">.ts</span><br>  <span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span>: T1 = &#123;<br>      name: <span class="hljs-string">&#x27;123&#x27;</span><br>  &#125;;<br></code></pre></td></tr></table></figure><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-comment">// ts.d.ts</span><br><span class="hljs-keyword">interface</span> <span class="hljs-symbol">T1</span> &#123;<br>    name: <span class="hljs-built_in">string</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>运行结果：<br><img src="/images/ts1.png"><br>使用tsc 竟然报错，但是使用ts-loader + webpack ，可以编译成功？莫非ts-loader 和tsc编译的机制不一样，不应该呀！！！</p><p>仔细阅读官网，有这样一句话：<strong>tsc当命令行上指定了输入文件，tsconfig.json文件会被忽略</strong>，<br>解决方法有：<br>1.直接输入tsc命令，会按照相应的配置文件tsconfig.json 来查找文件并生成。</p><p>2.采用三斜线命令，在index.ts文件中写入<code>///&lt;reference path=&quot;..&quot;/&gt;</code>。</p><p>3.将.d.ts文件采用import模块的方式引入。</p><p>4.命令行上同时包含待执行的文件和相应的.d.ts文件。</p><p>但是，这边有个坑，如果执行的文件叫index.ts ,而相应的声明文件叫index.d.ts，运行tsc命令，则会报错找不到相应的类型定义。</p><p><img src="/images/ts2.png"></p><p>查看官网，会发现有如下的解释：需要注意编译器不会去引入那些可能做为输出的文件；比如，假设我们包含了index.ts，那么index.d.ts和index.js会被排除在外。 通常来讲，不推荐只有扩展名的不同来区分同目录下的文件。<br>所以声明文件index.d.ts 并未被在编译的时候包含进去，所以报错。<br>现在可以发现，tsc和ts-loader的编译机制并没有不一样。都是按照相应的tsconfig.json配置文件来查找并执行。</p><p><img src="/images/ts3.png"></p><p>学习ts晋升的一个好的方法就是查看别人写的.d.ts文件，并从中思考为何要这样写，这样可以从中发现很多自己的不足。<br>比如node.d.ts文件中，declare module ‘querystring’里 interface前加不加export 有什么区别，自己在本地试了下，不加export也可以通过modulename加.的属性来访问接口，猜测是由于之前ts没有考虑es6的export属性，估计之前的版本默认是export，为了兼容之前的版本所以export可加可不加，仅猜测…</p>]]></content>
    
    
    
    <tags>
      
      <tag>TS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>浅析Css中动画优化原理</title>
    <link href="/2018/09/18/css-animation/"/>
    <url>/2018/09/18/css-animation/</url>
    
    <content type="html"><![CDATA[<p>说到web前端开发，就不得不提到动画，动画是网站吸引用户的重要因素之一。<br>动画的实现一般有2种实现方式，通常说是命令式动画和声明式动画：<br>命令式动画：用JavaScript实现，优点是富有可操控性如暂停，取消等，缺点是占用JS主线程，可能会丢失帧。<br>声明式动画：用css实现，优点是浏览器会对动画进行优化，缺点是缺乏可操控性。</p><p>重点说下声明式动画，浏览器对动画的优化，如我们所知：在对DOM中的element进行动画时，尽量使用transform、opacity属性和will-change属性（实验中），如下：<br>位置的变化: transform:translate(x,y)<br>大小的变化: transform: scale(x)<br>角度的变化: transform：rotate(n)<br>透明度的变化: opacity:0~1<br>即将变化的属性：will-change: attr</p><p>为何使用这些属性动画性能就能得到优化？原因是因为GPU加速合成（GPU Accelerated Compositing），<br>那么，什么是GPU？  为何GPU可以加速？ Composite是什么？下面一一来解答。</p><p>GPU：图形处理器（Graphics Processing Unit），是显卡的核心，相当于CPU在计算机中的作用，由于GPU的核数多而缓存小，所以适合做海量数据的简单运算，而CPU则擅长计算比较复杂的任务逻辑。</p><p>为何GPU可以加速？<br>当CPU把图形绘制的任务分配给了GPU，则CPU可以去做其他的任务，同时GPU专心的绘制图像，从而实现并行操作，提高渲染效率， 同时GPU对涉及大量像素处理的绘制和合成操作有做专门的设计，所以要比CPU有效率。</p><p>合成（Composite）：<br><img src="/images/css1.png"><br>一般简单来说，浏览器渲染过程经过如下几个步骤，可以看出渲染层合成(Composite)是在绘制之后，屏幕展示之前。<br>那么为什么要形成合成层呢？简单介绍下浏览器渲染的原理。</p><p><img src="/images/css2.png"><br>如图所示，</p><ol><li>在一个HTML中，每一个Element有一个对应的DOM Node存在；</li><li>在DOM tree 中每个node节点都有一个LayoutObject 对应存在，LayoutObject 的作用是知道如何渲染它所对应的Dom Node；</li><li>多个LayoutObject 可能对应一个PaintLayer，一般拥有同一坐标空间的LayoutObject 属于同一个RenderLayer，或者与它的第一个拥有PaintLayer的祖先的LayoutObject 创建的PaintLayer拥有同一个。PaintLayer包含2个数组，包括当前层之上和之下的PaintLayer。PaintLayer的作用是使得网页的元素渲染能有正确的顺序和效果；</li><li>多个PaintLayer可能对应一个GraphicsLayer 。一些特殊的PaintLayer会被认为是合成层（composite），其中的一个原因就是前面诉说的对DOM元素动画使用了transform等属性，合成层（composite）单独拥有一个GraphicsLayer ,而其他的PaintLayer则和第一个拥有GraphicsLayer的祖先的PaintLayer创建的GraphicsLayer拥有同一个，GraphicsLayer的作用是作为纹理(texture)上传给 GPU ，然后由GPU绘画到屏幕上。</li></ol><p>在传统的渲染方式中，整个网页只有一个GraphicsLayer，任何一个Layer的内容更新都会引起相关所有层的重绘，那么这些都将造成CPU很大的负担。所以有了上面诉说的GPU加速合成即硬件渲染模式，利用合成器渲染，合成器跟踪最近一次被绘制后有变化的GraphicsLayer，只更新有变化的GraphicsLayer相对的texture，进而通过GPU 进程直接绘制到窗口上。</p><p>参考:<br><a href="https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome">https://www.chromium.org/developers/design-documents/gpu-accelerated-compositing-in-chrome</a><br><a href="http://taobaofed.org/blog/2016/04/25/performance-composite/">http://taobaofed.org/blog/2016/04/25/performance-composite/</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>How to resolve chrome autofill but JS cannot get input value until user interaction</title>
    <link href="/2018/09/18/chrome-autofill/"/>
    <url>/2018/09/18/chrome-autofill/</url>
    
    <content type="html"><![CDATA[<p>Recently our company refator the login page and redesign the UI. As u can see in the below ,chrome has autofill the password feature, but u also can see though the email and password is not empty, but the <code>login</code> button is also still disabled. So it’s weired.<br><img src="/images/chrome-js.png"></p><p>Here said this behavior is working as expected and mitigates a privacy/security attack,<br>values of auto-filled inputs on page load are not accessible through JS until a user interacts with a page.<br><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=1166619">https://bugs.chromium.org/p/chromium/issues/detail?id=1166619</a>,<br><a href="https://bugs.chromium.org/p/chromium/issues/detail?id=163072">https://bugs.chromium.org/p/chromium/issues/detail?id=163072</a></p><p>So then we need find a workaround about the behavior, and we find <code>window.getComputedStyle(element, null).getPropertyValue(&#39;appearance&#39;)</code> the value is <code>menulist-button</code>, so the we can from here to find a hack solution.</p><p>Detect the button is filled or not:</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const detectAutofill = (element: HTMLBaseElement): <span class="hljs-built_in">Promise</span>&lt;boolean&gt; =&gt;<br><br>  <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve)</span> =&gt;</span> &#123;<br><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br><br>      resolve(<span class="hljs-built_in">window</span>.getComputedStyle(element, <span class="hljs-literal">null</span>).getPropertyValue(<span class="hljs-string">&#x27;appearance&#x27;</span>) === <span class="hljs-string">&#x27;menulist-button&#x27;</span>);<br><br>    &#125;, <span class="hljs-number">600</span>);<br><br>  &#125;);<br></code></pre></td></tr></table></figure><p>Then we need add a variable to enable the submit button if the value is true:</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">const <span class="hljs-literal">[<span class="hljs-identifier">isPasswordAutoFilled</span>, <span class="hljs-identifier">setIsPasswordAutoFilled</span>]</span> = use<span class="hljs-constructor">State(<span class="hljs-params">false</span>)</span>; <span class="hljs-comment">// for enable the submit button</span><br><br>const passwordEl = use<span class="hljs-constructor">Ref(<span class="hljs-params">null</span>)</span>; <span class="hljs-comment">// put the ref on password element</span><br><br>use<span class="hljs-constructor">Effect(()</span> =&gt; &#123;<br><br>  const checkAutoFill = async<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> &#123;<br><br>    const passwordFilled = await detect<span class="hljs-constructor">Autofill(<span class="hljs-params">passwordEl</span>.<span class="hljs-params">current</span>)</span>;<br><br>    <span class="hljs-comment">// if the password is auto filled by chrome, then we set the value to the state.</span><br>    set<span class="hljs-constructor">IsPasswordAutoFilled(<span class="hljs-params">passwordFilled</span>)</span>;<br><br>  &#125;;<br><br>  check<span class="hljs-constructor">AutoFill()</span>;<br><br>&#125;, <span class="hljs-literal">[<span class="hljs-identifier">password</span>]</span>);<br></code></pre></td></tr></table></figure><p>Finally in submit we can add a retry to make sure the login success rate.</p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// then we can add a retry `variable` to retry again and limit the times max 2</span><br> <span class="hljs-keyword">if</span> (!password &amp;&amp; retry !== <span class="hljs-literal">true</span>) &#123;<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> submit(e, <span class="hljs-literal">true</span>), <span class="hljs-number">100</span>); <span class="hljs-comment">// waiting for trigger next submit</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>   <br> &#125;<br></code></pre></td></tr></table></figure><p> Though we do a hack for this improvement, but we don’t have a 100% to make sure the code is normal work, so we add some GA tracking in the code and log the related error information, the result is the code work as expected.</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
      <tag>Chrome</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>React中实现循环滑动效果难点</title>
    <link href="/2018/07/12/react-loop/"/>
    <url>/2018/07/12/react-loop/</url>
    
    <content type="html"><![CDATA[<p>最近有这样一个需求，在h5页面上，向左/向右滑动循环显示数据项，效果如下：</p><p><img src="/images/loop2.gif"></p><p>比如有3个页面，从第一个页面向左滑动到第二个页面，或者从第二个页面向左滑动到第三个页面，很简单，只需要将left从0%切换到-100%，或从-100%更换到-200%，然后在对left增加transition属性，如：<code>transition: left 0.5s</code>，就可以简单实现从第一张滑动到第二张，第二张到第三张，那么从第三个页面如何继续向左滑动到第一个页面，如果仅仅将left从-200%直接更换到0%，那么视觉上的效果就是从最后一页像右滑动到了第一页，滑动效果就变了，如下：</p><p><img src="/images/loop1.gif"></p><p>那么如何让从最后一张也保持不变的滑动效果滑动到第一张呢？</p><p>从最后一张直接改变属性到第一个页面是不太可能实现该效果了，要实现向左滑动，那么动画的left属性还是得变的越来越小，如<code>-100%--&gt; -200%</code>，为了实现这个效果，我们可增加一个过渡页面，该过渡页面可与第一个页面一样，就是第一个页面的clone页面，作为第4个页面，即第当从第三个页面滑动到第一个页面的时候，实际上滑动到的是该过渡页面（第4个页面），再当从第4个页面继续向左滑动的时候，那么应该滑动到第2个页面，这时可先设置<code>setState(&#123;left：0&#125;)</code>（render页面的时候并没有变化，由于当前的第4个页面就是第一个页面的clone)，在该<code>setState</code> 的<code>callback</code>中再设置<code>left: -100%</code>，这时left的属性就是从0–&gt;-100%，即实现了向左滑动的效果的条件。<br>代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span>.outerStyle = &#123;<br>    left: <span class="hljs-number">0</span><br>  &#125;;<br>  <span class="hljs-keyword">this</span>.setState(<br>    &#123;<br>      curPage: <span class="hljs-number">1</span>,<br>      outerStyle: <span class="hljs-keyword">this</span>.outerStyle<br>    &#125;,<br>    () =&gt; &#123;<br>      <span class="hljs-keyword">this</span>.outerStyle = &#123;<br>        left: `-$&#123;<span class="hljs-keyword">this</span>.indicator * <span class="hljs-number">100</span>&#125;%`,<br>        transition: `left <span class="hljs-number">0.</span>5s`<br>      &#125;;<br>       <span class="hljs-keyword">this</span>.setState(&#123;outerStyle: <span class="hljs-keyword">this</span>.outerStyle&#125;);<br>    &#125;<br>  );<br></code></pre></td></tr></table></figure><p>但是另一个问题又来了，为何<code>setState  left：0</code>好像没起作用， 浏览器直接从当前状态直接过度到了<code>setState callback</code>中的状态？</p><p>原来是由于在一个渲染帧中，<strong>浏览器会忽略中间的状态，直接渲染最后一个状态</strong>，所以其中的<code>left:0</code>效果会没有了，如A-&gt;B-&gt;C, B和C在一个渲染帧中，那么我们将直接看见从A-&gt;C的变化状态，而忽略B的状态，从根本上的解决该问题就是让这2个状态在2个渲染帧中，解决方法有如下：</p><p>1.将C的状态放在setTimeout中，最好timeout时间超过16.7ms（1/60），如果timeout设为0，在某些浏览器可能不工作<br> <figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>   <span class="hljs-built_in">this</span>.setState(&#123;outerStyle: <span class="hljs-built_in">this</span>.outerStyle&#125;);<br> &#125;, <span class="hljs-number">20</span>);<br></code></pre></td></tr></table></figure></p><p>2.采用requestAnimationFrame </p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">requestAnimationFrame(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>   <span class="hljs-built_in">this</span>.setState(&#123;outerStyle: <span class="hljs-built_in">this</span>.outerStyle&#125;);<br> &#125;);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>React</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mobx概览</title>
    <link href="/2018/06/12/mobx/"/>
    <url>/2018/06/12/mobx/</url>
    
    <content type="html"><![CDATA[<p>mobx是和redux一样用于对react进行状态管理，和redux相比，编写起来更加方便，简单。</p><p><img src="/images/mobx.png"><br><strong>Action</strong>：事件触发，更改Store 里的数据。<br><strong>State</strong>: 数据的存储。<br><strong>Reaction</strong>：相当于UI的改变。</p><p>和redux最主要不同的地方就是action触发，直接修改数据，UI界面更新。背后的原理是proxy，在set 和get 相应的属性上进行截，所以observable对象或者数组中通过用. 或者[]访问的属性都可被检测到变化。<br>而不需像redux中需手动书写纯函数返回新的state。手动书写纯函数感觉太麻烦了~</p><p>在mobx中，所有的方法都可以采用decorator实现， 采用decorator则需要配置babel <code>&quot;@babel/plugin-proposal-decorators&quot;</code>，个人更倾向于decorator，简单，快速，明了。</p><h3 id="mobx主要的方法："><a href="#mobx主要的方法：" class="headerlink" title="mobx主要的方法："></a>mobx主要的方法：</h3><ul><li><p><strong>Observable</strong>：包含object，array， map，boxed value（原始值，函数，原型对象)。</p></li><li><p><strong>autorun</strong>：一个响应式函数，自动运行，不会产生新的值，返回值为disposer，需手动回收，如打印日志。</p></li><li><p><strong>computed</strong>：当需要通过另一个observable属性计算获取一个新值，如form表单中验证submit button 是否valid。</p></li><li><p><strong>action</strong>：一般为事件触发，改变数据，异步采用runInAction（如async/await中）。</p></li><li><p><strong>when</strong>：<code>when(()=&gt;boolean, ()=&gt; effect)</code>，当第一个函数执行为true时，才会执行第二个函数，且只执行一遍。</p></li><li><p><strong>reaction</strong>： 是对autorun更精确的响应，<code>reaction(() =&gt; data, (data, reaction) =&gt; &#123; sideEffect &#125;, options?)</code>，第一个函数用来追踪并返回数据作为第二个函数的输入。 不同于 autorun 的是当创建时效果 函数不会直接运行，只有在数据表达式首次返回一个新值后才会运行。 在执行效果函数时访问的任何observable都不会被追踪。</p></li></ul><h3 id="set-vs-extendObservable-vs-decorate"><a href="#set-vs-extendObservable-vs-decorate" class="headerlink" title="set vs extendObservable vs decorate"></a>set vs extendObservable vs decorate</h3><p>他们都可以对对象上还不存在的属性进行添加并observable<br>区别：</p><ul><li><strong>set</strong>：<code>set(obj, key, val)</code>,如果要获取新添加的key值，必须使用<code>get(obj, key)</code>，否则获取不到新加的属性值。</li><li><strong>extendObservable</strong>: 用在直接在目标实例上引入属性。4.x版本<code>object.keys</code>或者<code>for...in</code>并不能自动获取添加的属性。在最新的版本中可以自动获取新加的属性。</li><li><strong>decorate</strong>：用在目标上的原型引入属性。<br>当然mobx建议<strong>最佳的方法</strong>就是使用<code>Observable.map</code>, 它本身创建的就是一个动态的映射关系。</li></ul><h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a>注意点：</h3><p>observable里的array<strong>并不是</strong>array对象，是mobx自己创建的一个类数组对象，并拥有相应的方法，如果需转为普通的array对象，则可以采用<code>slice()</code>方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Babel介绍</title>
    <link href="/2018/06/11/babel-ES6-IE8/"/>
    <url>/2018/06/11/babel-ES6-IE8/</url>
    
    <content type="html"><![CDATA[<p>babel默认将es6语法转为es5，如果想要在低版本浏览器上支持es6新增的api，如Array.prototype.from等方法，则需要添加polyfill。</p><h5 id="babel的一些主要概念介绍"><a href="#babel的一些主要概念介绍" class="headerlink" title="babel的一些主要概念介绍"></a>babel的一些主要概念介绍</h5><ul><li><p><strong>babel-preset-env</strong> ： 将es2015 ，es2016，es2017的语法转为es5。</p></li><li><p><strong>babel-core</strong>： 包含transform方法，任何需要引用babel处理文件的，则需调用该方法。</p></li><li><p><strong>babel-regiser</strong>：node中，替换require的引用，在文件中require(‘babel-register’)， 然后require 相应的es6 文件，直接运行node file.js, 如果需要polyfill还是需要引入的 。babel-register相当于对本文件中的require的文件进行转换编译，除了自己，使用方法如下：<br><img src="/images/1.png"><br><img src="/images/2.png"><br><img src="/images/3.png"></p></li><li><p><strong>babel-cli</strong>： 提供命令行执行转换es6文件并输出。</p></li><li><p><strong>babel-node</strong>： 相当于提供了个node 命令，但是会在执行node命令之前对es6进行编译，不建议在production中使用，由于编译中的缓存数据存储在内存中，造成性能问题。</p></li><li><p><strong>babel-polyfill</strong>: 模拟了一个全面的es5环境，添加polyfill有3种方法：</p><ol><li><p>全局添加polyfill，在webpack的entry中，例如：entry：[‘babel-plyfill’, ‘.index.js’]；缺点是全局污染。</p></li><li><p>babel-runtime，将所需的polyfill 额外打包成一个help.js 文件，然后再所需之处对这个文件进行引用，手动引用的工作可以用babel-plugin-transform-runtime插件，在.babelrc文件中配置，会自动替换手动的工作。缺点是不能应用实例方法。理由：如”foobar”.includes(“foo”) （在转换时难找到相对应的目标方法替换），可以转换静态方法。</p></li><li><p>babel-preset-env, 有个配置选项useBuiltIn，如果true则自动添加所需的babel-polyfill，而在入口文件处需引入require（’babel-polyfill’），这也是官方推荐的。配置如下：<br> <img src="/images/4.png"></p></li></ol></li></ul><h4 id="重点说下polyfill，有了polyfill我们可以在任何低版本的浏览器上写es6的新方法，由于公司支持到ie8，所以试下在IE8上去写es6，然后想法很美好，现实很骨感！"><a href="#重点说下polyfill，有了polyfill我们可以在任何低版本的浏览器上写es6的新方法，由于公司支持到ie8，所以试下在IE8上去写es6，然后想法很美好，现实很骨感！" class="headerlink" title="重点说下polyfill，有了polyfill我们可以在任何低版本的浏览器上写es6的新方法，由于公司支持到ie8，所以试下在IE8上去写es6，然后想法很美好，现实很骨感！"></a>重点说下polyfill，有了polyfill我们可以在任何低版本的浏览器上写es6的新方法，由于公司支持到ie8，所以试下在IE8上去写es6，然后想法很美好，现实很骨感！</h4><p>步骤如下：</p><h5 id="新建个main-js-，里面包含最简单的es6语法，箭头和map函数。"><a href="#新建个main-js-，里面包含最简单的es6语法，箭头和map函数。" class="headerlink" title="新建个main.js ，里面包含最简单的es6语法，箭头和map函数。"></a>新建个main.js ，里面包含最简单的es6语法，箭头和map函数。</h5><p><img src="/images/5.png"><br>webpack.config.js配置：<br><img src="/images/6.png"><br>.babelrc配置：<br><img src="/images/7.png"><br>以为这样就外事大吉了，少年你还是太年轻了，打开IE8，报错如下，缺少标识符：<br><img src="/images/8.png"><br>点击进去查看：<br><img src="/images/9.png"><br>查找资料，得出结论是IE8中用的是es3的语法，所以需要将es5的语法转为es3的，利用babel提供的2个插件：transform-es3-member-expression-literals 和transform-es3-property-literals ，这2个插件做的事情其实是将关键字如default、return等，写法改变一下，给关键字加上引号，重新生成结果如下：<br><img src="/images/10.png"></p><p>然后打包，刷新浏览器，发现报堆栈溢出，报错如下，<br><img src="/images/17.png"><br><img src="/images/18.png"><br>去Github上查看，发现原来babel-polyfill 中包含的core-js是不可以经过babel转换的。<br><img src="/images/19.png"></p><p>于是在babel-loader转换处，exclude 对core-js的转换：<br><img src="/images/20.png"></p><p>刷新页面，又报错了：<br><img src="/images/21.png"></p><p>原因是由于Object.defineProperty只能用在DOM对象上，如果传入普通的js对象，则报错。自己如果手动hack，为抛错的那行加上try，catch则一切正常了。阿里的<a href="http://www.aliued.com/?p=3240">这篇文章</a> 提供了很好的分析思路。<br>附上github上未被解决的理由…<br><img src="/images/22.png"><br><img src="/images/29.png"></p><hr><h5 id="babel-polyfill这条路走不通，按照上面core-js作者说的，还是有方法可以实现的，查找资料说是可以通过es5-shim（即es3对es5某些方法的实现）实现试试："><a href="#babel-polyfill这条路走不通，按照上面core-js作者说的，还是有方法可以实现的，查找资料说是可以通过es5-shim（即es3对es5某些方法的实现）实现试试：" class="headerlink" title="babel-polyfill这条路走不通，按照上面core-js作者说的，还是有方法可以实现的，查找资料说是可以通过es5-shim（即es3对es5某些方法的实现）实现试试："></a>babel-polyfill这条路走不通，按照上面core-js作者说的，还是有方法可以实现的，查找资料说是可以通过es5-shim（即es3对es5某些方法的实现）实现试试：</h5><p><img src="/images/30.png"><br>打包，刷新浏览器，运行正确了，alert了三次(此处放鞭炮)。</p><p>如果需要增加对import 和export的依赖，如代码：<br><img src="/images/23.png"></p><p>刷新运行，报错了，<br><img src="/images/24.png"><br><img src="/images/25.png"></p><p>根据babel官网的介绍，需要在presets里增加loose： true 选项。<br><img src="/images/26.png"><br>最终.babelrc的配置如下：<br><img src="/images/27.png"></p><p>以上代码在如下环境中运行：<br><img src="/images/28.png"></p><p>在ie8环境中基本实现了es6的写法，如果需支持其他的写法，则另需要增加插件polyfill的引用，如：promise，Object.assign等方法。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript装饰者模式</title>
    <link href="/2017/12/24/js-decorator-mode/"/>
    <url>/2017/12/24/js-decorator-mode/</url>
    
    <content type="html"><![CDATA[<h3 id="装饰者模式："><a href="#装饰者模式：" class="headerlink" title="装饰者模式："></a>装饰者模式：</h3><p>在不改变对象自身的基础上,在程序运行期间给对象动态地添加新功能。</p><p>例如我们要修改以前的一个功能，<code>function a()&#123;...&#125;</code>,一般我们的做法是直接在<code>a</code>函数中添加代码，但是这样容易引起bug，万一别处调用了该函数，而我们万一又没测试到，这时可以引入装饰者模式。如：</p><span id="more"></span><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">a</span>(<span class="hljs-params"></span>)</span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;111&#x27;</span>);<br>&#125;<br><br><span class="hljs-keyword">var</span> _a = a;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">b</span>(<span class="hljs-params"></span>)</span>&#123;<br>  _a();<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;222&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样在不影响a函数的前提下又复用了a函数的功能。当然<code>a</code>函数的<code>this</code>指向必须是<code>window</code>，如果是<code>document.getElementById</code> 则这时就会报错，解决的方法当然是设置正确的this指向，可采用<code>apply</code>方法调用。</p><p>而采用AOP方式实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> before = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"> beforefn, fn</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    beforefn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>    <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> a = before(<br>  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span>)&#125;,<br>  <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">3</span>)&#125;<br>);<br>a = before(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>);&#125;, a);<br>a(); <br><br></code></pre></td></tr></table></figure><p>输出:<br>1<br>2<br>3</p><p>上面的代码可以使用在比如在提交表单之前可以进行一些基本的验证，比如<code>submit.before(validator)</code>;</p><h4 id="装饰者模式-vs-代理模式："><a href="#装饰者模式-vs-代理模式：" class="headerlink" title="装饰者模式 vs 代理模式："></a>装饰者模式 vs 代理模式：</h4><p>装饰者模式和代理模式都提供了对原先的对象的引用，向原对象发送请求。而他们的区别是：<br>1.代理模式中代理对象和原对象之间的关系是确定的，而装饰者模式用于在原对象的基础上动态添加新功能，也就是一开始关系是不确定的。<br>2.代理模式通常只有一层对原对象的引用，而装饰者模式经常会形成一条长长的装饰链。<br>3.装饰者模式是为对象增加新的职责和行为，而代理做的事情还是跟原对象一样。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS-设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript中介模式</title>
    <link href="/2017/12/24/js-mediator-mode/"/>
    <url>/2017/12/24/js-mediator-mode/</url>
    
    <content type="html"><![CDATA[<h3 id="中介模式："><a href="#中介模式：" class="headerlink" title="中介模式："></a>中介模式：</h3><p>当对象和对象之间存在多对多的关系时，对象之间存在紧耦合关系，如果修改某一处对象，则可能会导致整个程序down了。而中介者模式是解耦对象之间的紧耦合关系，让对象和对象之间不再是直接联系，让是让对象和中介联系，通过中介获得相关的信息来处理。</p><p>生活中常见的场景是比如火车出发和到达站台，需要由指挥调度中心来发出信息，该列车是否可以出发了，或者该列车应该停靠哪个站台，而不用让该列车去联系其他列车A站台是否可停靠等信息。 让列车之间的相互联系仅通过调度中心就可以获得相关信息。这样维护起来也很简单。</p><p>举例如，经常在网上买东西，比如买电脑，电脑有颜色选择，数量选择等信息，同时每选择某个属性，都会去要拿其他的属性一起去查询是否还有足够的库存让用户可以购买，即是否可以点击购买button。如果没有足够的库存，或者某个属性没有选择，那么button将disabled，如果正常写代码的话，那么在比如颜色选择上：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">var</span> <span class="hljs-built_in">color</span> = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;color&#x27;</span>);<br><span class="hljs-keyword">var</span> number = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;number&#x27;</span>);<br><span class="hljs-keyword">var</span> buyBtn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;buy&#x27;</span>);<br><span class="hljs-keyword">var</span> colorInput = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;colorInput&#x27;</span>);<br><span class="hljs-keyword">var</span> info = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;info&#x27;</span>);<br><br><span class="hljs-keyword">var</span> stock = &#123;<br>  <span class="hljs-attribute">red</span>: <span class="hljs-number">4</span>,<br>  <span class="hljs-attribute">black</span>: <span class="hljs-number">3</span><br>&#125;;<br><br><span class="hljs-built_in">color</span>.onchange = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> <span class="hljs-built_in">color</span> = <span class="hljs-keyword">this</span>.value;<br>  <span class="hljs-keyword">var</span> num = number.value;<br>  <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">color</span>) &#123;<br>    info.innerHTML = <span class="hljs-string">&#x27;need select color&#x27;</span>;<br>    buyBtn.disabled = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(!num) &#123;<br>     info.innerHTML = <span class="hljs-string">&#x27;need select num&#x27;</span>;<br>     buyBtn.disabled = <span class="hljs-literal">true</span>;<br>     <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-keyword">if</span>(num &gt; stock[<span class="hljs-built_in">color</span>]) &#123;<br>    info.innerHTML = <span class="hljs-string">&#x27;no stock&#x27;</span>;<br>    buyBtn.disabled = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  buyBtn.disabled = <span class="hljs-literal">false</span>;<br>  info.innerHTML = <span class="hljs-string">&#x27;can buy&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么对于在数量的选择上也会有相同的如上代码，那么如果以后再增加一个属性比如内存大小，那么在每个属性的onchange事件里面都需要增加相应的判断代码，维护起来想到麻烦。</p><p>采用中介者模式改进代码如下：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">var</span> <span class="hljs-built_in">color</span> = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;color&#x27;</span>);<br><span class="hljs-keyword">var</span> number = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;number&#x27;</span>); <br><span class="hljs-keyword">var</span> buyBtn = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;buy&#x27;</span>);<br><span class="hljs-keyword">var</span> info = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;info&#x27;</span>);<br><br><span class="hljs-keyword">var</span> stock = &#123;<br>  <span class="hljs-attribute">red</span>: <span class="hljs-number">4</span>,<br>  <span class="hljs-attribute">black</span>: <span class="hljs-number">3</span><br>&#125;;<br><br><span class="hljs-keyword">var</span> middleAgent = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(obj.currentTarget === <span class="hljs-built_in">color</span>) &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;color onchange&#x27;</span>);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (obj.currentTarget === number) &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;number onchange&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">color</span>.value) &#123;<br>      info.innerHTML = <span class="hljs-string">&#x27;need select color&#x27;</span>;<br>      buyBtn.disabled = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!number.value) &#123;<br>      info.innerHTML = <span class="hljs-string">&#x27;need select number&#x27;</span>;<br>      buyBtn.disabled = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(number.value &gt; stock[<span class="hljs-built_in">color</span>.value]) &#123;<br>      info.innerHTML = <span class="hljs-string">&#x27;no stock&#x27;</span>;<br>      buyBtn.disabled = <span class="hljs-literal">true</span>;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br>    buyBtn.disabled = <span class="hljs-literal">false</span>;<br>    info.innerHTML = <span class="hljs-string">&#x27;can buy&#x27;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">color</span>.onchange = middleAgent(<span class="hljs-keyword">this</span>);<br>number.oninput = middleAgent(<span class="hljs-keyword">this</span>);<br></code></pre></td></tr></table></figure><p>如此这样，每个属性的变化都只需要和middleAgent中介者通信就可以，对象之间不需要知道彼此的存在，它们只需通过中介者对象来互相影响对方。</p><p>一般来说，我们再代码中对象之间有联系是正常的，但是如果对象之间的关系已经复杂到难以维护，则可以考虑使用中介者模式来改进。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS-设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript职责链模式</title>
    <link href="/2017/12/24/js-chain-mode/"/>
    <url>/2017/12/24/js-chain-mode/</url>
    
    <content type="html"><![CDATA[<h3 id="职责链模式："><a href="#职责链模式：" class="headerlink" title="职责链模式："></a>职责链模式：</h3><p>将多个接收者串成一条链子的形式，让请求的对象在该条链子上被传送，直到某个对象可以处理。</p><p>场景是在对象发送出时，有多个接收者可以处理该发送者的请求，一般在业务中会经常遇到一个场景，点击某个button以后，比如投资，第一个条件是否实名过，如果未实名，则提示需实名，第二个条件是如果已经实名，当余额不足时，弹出dialog让去充值，第三个条件是当余额充足时，是否已经测评过，如果未测评，则弹出dialog需测评。当这3个条件都满足时，最后去请求投资。</p><p>如果我们一般的编写代码则是，</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> autonym = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(!user.hasAuth) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;need auth&#x27;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    recharge(user);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> recharge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(!user.amountNoMeet) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;need recharge&#x27;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    survey(user);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> survey = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(!user.hasSurvey) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;need survey&#x27;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    gotoInvest();<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> gotoInvest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;invest success!&#x27;</span>);<br>&#125;;<br></code></pre></td></tr></table></figure><p>通常对于一系列的判断条件我们会如上这样写，这样写弊端是当这三个条件中增加一个判断条件，比如是否余额充足后再判断投资额度是否还有，那么我们就需要去修改recharge函数，并新增一个函数，这样就相当于把原来的链子砍断，然后再新增一个节点并和前后连接起来，维护起来很麻烦。</p><p>那我们采取职责链模式写法改进如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> autonym = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(!user.hasAuth) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;need auth&#x27;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;next&#x27;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> recharge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(!user.amountNoMeet) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;need recharge&#x27;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;next&#x27;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> survey = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(!user.hasSurvey) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;need survey&#x27;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;next&#x27;</span>;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> gotoInvest = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;invest success!&#x27;</span>);<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chain</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">fn</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.fn = fn;<br>    <span class="hljs-built_in">this</span>.next = <span class="hljs-literal">null</span>;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">setNextProcessor</span>(<span class="hljs-params">next</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.next = next;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">handleRequest</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">var</span> rt = <span class="hljs-built_in">this</span>.fn.apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>    <span class="hljs-keyword">if</span>(rt === <span class="hljs-string">&#x27;next&#x27;</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.next &amp;&amp; <span class="hljs-built_in">this</span>.next.handleRequest.apply(<span class="hljs-built_in">this</span>.next, <span class="hljs-built_in">arguments</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> rt;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> autonymChain = <span class="hljs-keyword">new</span> Chain(autonym);<br><span class="hljs-keyword">var</span> rechargeChain = <span class="hljs-keyword">new</span> Chain(recharge);<br><span class="hljs-keyword">var</span> surveyChain = <span class="hljs-keyword">new</span> Chain(survey);<br><span class="hljs-keyword">var</span> gotoInvestChain = <span class="hljs-keyword">new</span> Chain(gotoInvest);<br><br>autonymChain.setNextProcessor(rechargeChain);<br>rechargeChain.setNextProcessor(surveyChain);<br>surveyChain.setNextProcessor(gotoInvestChain);<br><br>autonymChain.handleRequest(&#123;<span class="hljs-attr">hasAuth</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">amountNoMeet</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">hasSurvey</span>: <span class="hljs-literal">false</span>&#125;);<br><br></code></pre></td></tr></table></figure><p>上面代码输出need survey，如果再新增一个条件余额充足后再判断投资额度是否还有，则：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> amountLimit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">user</span>) </span>&#123;<br>  <span class="hljs-keyword">if</span>(user.amountLimit) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;amount limit&#x27;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;next&#x27;</span>;<br>  &#125;<br>&#125;<br><span class="hljs-keyword">var</span> amountLimitChain = <span class="hljs-keyword">new</span> Chain(amountLimit);<br><br>rechargeChain.setNextProcessor(amountLimitChain);<br>amountLimitChain.setNextProcessor(surveyChain);<br><br></code></pre></td></tr></table></figure><p>这样就无需修改recharge函数，只需新增一个节点，并修改下顺序即可，并且可以一目了然的看清这些节点之间的顺序和数量。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS-设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript享元模式</title>
    <link href="/2017/12/23/js-flyweight-mode/"/>
    <url>/2017/12/23/js-flyweight-mode/</url>
    
    <content type="html"><![CDATA[<h3 id="享元模式："><a href="#享元模式：" class="headerlink" title="享元模式："></a>享元模式：</h3><p>剥离出对象的外部状态和内部状态，将内部状态放在类中，外部状态可以通过同一个对象共享，即用相对较少的共享对象取代大量对象，常用在创建很多类似的对象而导致内存过高的场景中。</p><span id="more"></span><p>最常见的场景就是上传文件，上传的文件有文件名，文件大小，上传文件的方式，分为普通上传和极速上传。如下:</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UploadFile</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, id, name, size</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.type = <span class="hljs-keyword">type</span>;<br>    <span class="hljs-built_in">this</span>.id = id;<br>    <span class="hljs-built_in">this</span>.name = name;<br>    <span class="hljs-built_in">this</span>.size = size;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">delete</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;delete file&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> startUpload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, files</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; files.length; i++ ) &#123;<br>    <span class="hljs-keyword">new</span> UploadFile(<span class="hljs-keyword">type</span>, i, file[i].name, file[i].size);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如上实现代码，如果用户同时上传了几千个文件，那么同时也创建了几千个对象，就会导致内存占用过高。</p><p>使用享元模式来改进代码，将对象的内部状态剥离出来，即不变的状态，即文件的上传方式，而对象的外部状态如文件名，文件大小是外部状态，实现如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UploadFile</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"><span class="hljs-keyword">type</span></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.type = <span class="hljs-keyword">type</span>;<br>  &#125;<br>   <span class="hljs-function"><span class="hljs-title">delete</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;delete file&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> uploadFactory = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> cache = &#123;&#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-keyword">type</span></span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(cache[<span class="hljs-keyword">type</span>]) &#123;<br>      <span class="hljs-keyword">return</span> cache[<span class="hljs-keyword">type</span>];<br>    &#125; <br>    <span class="hljs-keyword">return</span> cache[<span class="hljs-keyword">type</span>] = <span class="hljs-keyword">new</span> UploadFile(<span class="hljs-keyword">type</span>);    <br>  &#125;<br>&#125;)();<br><br><span class="hljs-keyword">var</span> uploadManager = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, id, name, size</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> obj = uploadFactory(<span class="hljs-keyword">type</span>);<br>  obj[<span class="hljs-string">&#x27;id&#x27;</span>] = id;<br>  obj[<span class="hljs-string">&#x27;name&#x27;</span>] = name;<br>  obj[<span class="hljs-string">&#x27;size&#x27;</span>] = size;<br>&#125;;<br><br><span class="hljs-keyword">var</span> startUpload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, files</span>) </span>&#123;<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; files.length; i++ ) &#123;<br>    uploadManager(<span class="hljs-keyword">type</span>, i, file[i].name, file[i].size);<br>  &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>如此这样一来，创建的实例对象就只有2个，而文件的其他外部属性则通过id区别保存在同一个实例对象上。通过享元模式则得到了实例对象的大幅度释放。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS-设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript模板模式</title>
    <link href="/2017/12/22/js-template-mode/"/>
    <url>/2017/12/22/js-template-mode/</url>
    
    <content type="html"><![CDATA[<h3 id="模板模式："><a href="#模板模式：" class="headerlink" title="模板模式："></a>模板模式：</h3><p>模板模式是由2部分组成，第一部分是抽象父类，第二部分是子类实现，父类是对子类接口方法的定义和实现，而子类需实现父类定义的方法接口，也可以覆盖父类的方法实现。</p><span id="more"></span><p>js中并没有抽象类，那么抽象类是不可以被实例化的，可以这样检查：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Abstract</span> </span>&#123;<br>  constructor() &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span><span class="hljs-type"></span>.target === Abstract) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-type">TypeError</span>(<span class="hljs-string">&#x27;不能实例化抽象父类&#x27;</span>);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>同时如果子类没有实现该方法，但是我们可以再父类原型方法中抛错，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">Parent.prototype.mustBeExtend = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;子类必须实现该方法&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>模板顾名思义，是一个模板，即将子类中的共有的方法抽离出来生成一个父类，并让子类继承该模板父类。</p><p>如鸭子会叫，会吃，鸡也会叫，会吃，但是鸭子会游泳，鸡会飞，则会叫，会吃则可以抽离出来，而他们之间的不同则可以由子类自己实现，如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span>.target === Animal) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">&#x27;不能实例化抽象父类Animal&#x27;</span>);<br>    &#125;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">eat</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;eat&#x27;</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">shout</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;shout&#x27;</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">specific</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;子类必须实现该方法&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Duck</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-title">specific</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;游泳&#x27;</span>);<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Chicken</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span></span>&#123;<br>   <span class="hljs-function"><span class="hljs-title">specific</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;会飞&#x27;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在js中，其实很多时候我们选择的是高阶函数来代替模板模式。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS-设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript命令模式</title>
    <link href="/2017/12/22/js-command-mode/"/>
    <url>/2017/12/22/js-command-mode/</url>
    
    <content type="html"><![CDATA[<h3 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h3><p>命令是指执行特定事情的一个指令，在js中，其实高阶函数就是对命令模式的应用，将函数作为参数在整个生命周期中传递，那么函数参数就是个命令指令。</p><p>最常见的使用场景是请求者和接收者之间并不知道对方是谁，通过命令(一般是函数)来将彼此之间连接起来。</p><p>如果写UI的和js逻辑的是2个人，对于写UI的并不关注比如button的click事件是如何执行的，而只是预留一个onclick事件。<br>对于写js逻辑的也并不关注UI是如何实现的，只需要实现事件函数执行某种功能，比如点击button弹窗出现，或执行动画等。</p><p>例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> dialog = &#123;<br>  <span class="hljs-function"><span class="hljs-title">show</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;show dialog&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> animation = &#123;<br>  <span class="hljs-function"><span class="hljs-title">start</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;show animation&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> setCommand = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">btn, cmd</span>) </span>&#123;<br>  btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>    cmd.run();<br>  &#125;;<br>&#125;;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">showDialogCommand</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">receiver</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.receiver = receiver;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.receiver.show();<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">startAnimationCommand</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">receiver</span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.receiver = receiver;<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">this</span>.receiver.start();<br>  &#125;<br>&#125;<br><br>setCommand(btn1, <span class="hljs-keyword">new</span> showDialogCommand(dialog));<br>setCommand(btn2, <span class="hljs-keyword">new</span> startAnimationCommand(animation));<br><br></code></pre></td></tr></table></figure><p>从以上代码可以看出，通过setCommand函数和相关command的类，将点击button显示dialog，开始运行动画等事件和UI分离开来，即写ui的通过setCommand来调用相关的click事件。</p><p>当然也可以不采用面向对象的方式来实现，如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> dialog = &#123;<br>  <span class="hljs-function"><span class="hljs-title">show</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;show dialog&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> animation = &#123;<br>  <span class="hljs-function"><span class="hljs-title">start</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;show animation&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> btnClick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">btn, fn</span>) </span>&#123;<br>  btn.onclick = fn;<br>&#125;;<br><br>btnClick(btn1, dialog.show);<br>btnClick(btn2, animation.start);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS-设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript组合模式</title>
    <link href="/2017/12/22/js-compose-mode/"/>
    <url>/2017/12/22/js-compose-mode/</url>
    
    <content type="html"><![CDATA[<h3 id="组合模式："><a href="#组合模式：" class="headerlink" title="组合模式："></a>组合模式：</h3><p>组合模式是用小的子对象来构建更大的对象，而这些小的子对象本身也许是由更小的对象构成的。父对象和子对象拥有共同的对象接口，而他们可以组合在一起组成一个更强大的数据结构。一般由子对象进行处理，如果传递到还是非子对象，则继续往下传递直到子对象为止。</p><p>类似于命令模式将事件包装成有统一接口的模式，而组合模式就是父对象和子对象就是有相同的对外接口，这里的父对象和子对象并不是父子关系，只是包含组合关系。</p><p>比如一个页面上有个button，点击后先开始了loading动画，然后弹框显示提示，最后跳转到别的网站，这3组动作，让我们用组合模式实现如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> loading = &#123;<br>  <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;child can not be added&#x27;</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;show loading&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> dialog = &#123;<br>  <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;child can not be added&#x27;</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;show dialog&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> link = &#123;<br>  <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;child can not be added&#x27;</span>);<br>  &#125;<br>  <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;redirect link&#x27;</span>);<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> macroCommand = &#123;<br>  <span class="hljs-attr">cmdLists</span>: [],<br>  <span class="hljs-function"><span class="hljs-title">add</span>(<span class="hljs-params">cmd</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.cmdLists.push(cmd);<br>  &#125;,<br>  <span class="hljs-function"><span class="hljs-title">run</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.cmdLists.length; i++) &#123;<br>      <span class="hljs-built_in">this</span>.cmdLists[i].run();<br>    &#125;<br>  &#125;<br>&#125;;<br><br>macroCommand.add(loading);<br>macroCommand.add(dialog);<br>macroCommand.add(link);<br><br><span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;btn&#x27;</span>).onclick = macroCommand.run;<br><br></code></pre></td></tr></table></figure><p>当点击按钮以后会依次显示<code>show loading</code>, <code>show dialog</code>,<code>redirect link</code>，上述代码中，loading, dialog, link对象即是子对象，macroCommand即是父对象，他们都拥有相同的方法run，add，对于外界来说调用他们的方式是一样的。</p><p>可以看出组合模式的好处有对于未来有新增的子对象时，遍历的操作还是一样的，同时避免了打破主方法的封闭-开放原则。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS-设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript观察者模式</title>
    <link href="/2017/12/22/js-observe-mode/"/>
    <url>/2017/12/22/js-observe-mode/</url>
    
    <content type="html"><![CDATA[<h3 id="观察者模式："><a href="#观察者模式：" class="headerlink" title="观察者模式："></a>观察者模式：</h3><p>是一对多的模式，当订阅到某个对象上，当该对象改变时，将会通知所有依赖它的对象。</p><p>在js中，很多都是观察者模式，比如事件的click，先在某个元素上注册一个onclick事件，但并不知道该click事件什么时候会触发，待等到用户触发的时候再执行函数。类似的，在node中Events事件也是观察者模式，emit触发某个事件，然后再on事件中就会收到事件触发的信息。</p><p>观察者模式可以替代异步的callback，在时间上可以非同步，弱化对象之间的联系。</p><p>其实观察者模式的主要特点就是先找个对象将注册监听的函数放进去，一般为数组存放，之后当需要触发事件时，将数组中的函数拿出来循环遍历。</p><p>举个简单的例子，例如：<br>当登录以后，刷新网页头部的某些信息，比如用户名，会员等级，积分等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> event = &#123;<br>  <span class="hljs-attr">listeners</span>: [],<br>  addListener = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>    <span class="hljs-built_in">this</span>.listeners.push(fn);<br>  &#125;,<br>  emit = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">this</span>.listeners.length; i++) &#123;<br>      <span class="hljs-built_in">this</span>.listeners[i].apply(<span class="hljs-built_in">this</span>, <span class="hljs-built_in">arguments</span>);<br>    &#125;<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">var</span> nameRefresh = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;name refresh&#x27;</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> vipRefresh = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;vip refresh&#x27;</span>);<br>&#125;;<br><br><span class="hljs-keyword">var</span> scoreRefresh = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;score refresh&#x27;</span>);<br>&#125;;<br><br><span class="hljs-comment">// 注册事件</span><br>event.addListener(nameRefresh);<br>event.addListener(vipRefresh);<br>event.addListener(scoreRefresh);<br><br><span class="hljs-comment">// 当登录后调用emit</span><br><br>event.emit();<br><br></code></pre></td></tr></table></figure><p>当然，观察者模式也是有缺点的，如果注册监听了某个事件，但是该事件一直都未触发过，那么该注册的函数将会一直存在内存中，虽然可以弱化对象之间的联系，但是如果过度使用的话，出现bug会很难debug。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS-设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript代理模式</title>
    <link href="/2017/12/22/js-proxy-mode/"/>
    <url>/2017/12/22/js-proxy-mode/</url>
    
    <content type="html"><![CDATA[<h3 id="代理模式："><a href="#代理模式：" class="headerlink" title="代理模式："></a>代理模式：</h3><p>当某个接口或者对象不满足我们的需求时，再重新定义一个对象来满足需求，重新定义的对象然后访问本体对象。</p><p>在代码中我们经常会遇到，如果某个ajax请求已经请求过了，那么将该api返回的数据结果缓存起来，那么下次再次请求该api，则会先从缓存中查找是否有该值，如果有，则返回，否则请求。这种情况提供的缓存逻辑，也属于代理模式。</p><p>通常我们也会遇到监听window上的scroll事件，当用户滚动鼠标滑轮时，将会触发scroll事件，如果滚动一下，会频繁触发scroll事件，即执行监听的函数太过于频繁，这时我们可以使用debounce函数(原理其实就是setTimeout)，加个时间限制，如果从最后一次事件触发之后某个时间端都没有滚动过，再执行监听的函数，那么使用debounce包装的scroll事件也是一种代理模式。</p><p>总之就是对于原对象不满足需求的情况下，来重新定义并封装来满足需求。</p><p>举个缓存代理例子：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">var</span> getDataByUrl = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) </span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>((resolve, reject) =&gt; &#123;<br>    resolve(<span class="hljs-built_in">url</span>);<br>  &#125;);<br>&#125;<br><br><span class="hljs-keyword">var</span> proxyGetData = (<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> cache = &#123;&#125;;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url</span>) </span>&#123;<br>    <span class="hljs-keyword">if</span>(cache[<span class="hljs-built_in">url</span>]) &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;from cache&#x27;</span>);<br>      <span class="hljs-keyword">return</span> cache[<span class="hljs-built_in">url</span>];<br>    &#125; <span class="hljs-title">else</span> &#123;<br>      <span class="hljs-keyword">var</span> data = getDataByUrl(<span class="hljs-built_in">url</span>);<br>      cache[<span class="hljs-built_in">url</span>] = data;<br>      <span class="hljs-keyword">return</span> data;<br>    &#125;<br>  &#125;<br>&#125;)();<br><br><span class="hljs-built_in">console</span>.log(proxyGetData(<span class="hljs-string">&#x27;123&#x27;</span>)); <br><span class="hljs-built_in">console</span>.log(proxyGetData(<span class="hljs-string">&#x27;123&#x27;</span>)); <span class="hljs-comment">//输出 from cache</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS-设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript适配器模式</title>
    <link href="/2017/12/21/js-adapter-mode/"/>
    <url>/2017/12/21/js-adapter-mode/</url>
    
    <content type="html"><![CDATA[<h3 id="适配器模式："><a href="#适配器模式：" class="headerlink" title="适配器模式："></a>适配器模式：</h3><p>是为了解决2个软件中由于接口不兼容的问题。</p><p>比如在现实生活中最常见的就是去国外，需要带转换插头，转换电压。在代码中，最常见的是当调用某个接口，返回的数据并不是我们想要的格式，一般我们不太可能去修改原有的接口，一是风险太大，不知道有没有别的地方使用，二是增加了工作量，修改原有的代码需将原先的代码逻辑理清并且保证不会产生regression的错误。</p><p>例如：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">var</span> getStudentNames = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> names = [<br>    &#123;<br>      <span class="hljs-attribute">id:</span><span class="hljs-string"> 1,</span><br><span class="hljs-string">      name</span>: <span class="hljs-string">&#x27;mike&#x27;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attribute">id:</span><span class="hljs-string"> 2,</span><br><span class="hljs-string">      name</span>: <span class="hljs-string">&#x27;tony&#x27;</span><br>    &#125;,<br>    &#123;<br>      <span class="hljs-attribute">id:</span><span class="hljs-string"> 3,</span><br><span class="hljs-string">      name</span>: <span class="hljs-string">&#x27;tina&#x27;</span><br>    &#125;<br>  ];<br>  <span class="hljs-keyword">return</span> names;<br>&#125;;<br><br><span class="hljs-keyword">var</span> generate = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) </span>&#123;<br>  <span class="hljs-keyword">var</span> names = fn();<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i&lt;names.length; i++) &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;id&#x27;</span>+i.id +<span class="hljs-string">&#x27;是&#x27;</span> + i.name + <span class="hljs-string">&#x27;同学&#x27;</span>);<br>  &#125;;<br>&#125;<br><br>generate(getStudentNames);<br><br></code></pre></td></tr></table></figure><p>一开始我们获取的是比如某兴趣班仅有4位同学，前端写死的，但是后来发现该兴趣班人员变化很快，改为后端返回接口数据来渲染，而后端返回的接口数据比如是</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">&#123;<br>  <span class="hljs-number">1</span>: <span class="hljs-string">&#x27;mike&#x27;</span>,<br>  <span class="hljs-number">2</span>: <span class="hljs-string">&#x27;tony&#x27;</span>,<br>  <span class="hljs-number">3</span>: <span class="hljs-string">&#x27;tina&#x27;</span>,<br>  <span class="hljs-number">4</span>: <span class="hljs-string">&#x27;jane&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>如果我们直接在generate函数上修改的话会出现之前提到的几种错误可能，所以这时会采用适配器模式，将返回的数据接口转换成generate函数所需要的数据结构。代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> adapter = function(<span class="hljs-keyword">data</span>) &#123;<br>  <span class="hljs-keyword">return</span> function() &#123;<br>    <span class="hljs-keyword">return</span> Object.keys(<span class="hljs-keyword">data</span>).map((<span class="hljs-keyword">val</span>, index)=&gt; &#123;<br>      <span class="hljs-keyword">var</span> obj = &#123;&#125;;<br>      obj.id= <span class="hljs-keyword">val</span>;<br>      obj.name = <span class="hljs-keyword">data</span>[<span class="hljs-keyword">val</span>];<br>      <span class="hljs-keyword">return</span> obj;<br>    &#125;);<br>  &#125;<br>&#125;;<br><br>generate(adapter(<span class="hljs-keyword">data</span>));<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS-设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript状态模式</title>
    <link href="/2017/12/21/js-state-mod/"/>
    <url>/2017/12/21/js-state-mod/</url>
    
    <content type="html"><![CDATA[<h3 id="状态模式："><a href="#状态模式：" class="headerlink" title="状态模式："></a>状态模式：</h3><p>将对应的状态信息和状态变化保存在各自的类中，在主控制的类中，只需对所有的状态进行初始化即可，这样可一眼在构造函数中看出有多少种状态变化，避免了在主类中编写过多的if, else 条件语句来控制状态的变化，同时符合了代码的开放-封闭原则。</p><h4 id="那么什么是状态？"><a href="#那么什么是状态？" class="headerlink" title="那么什么是状态？"></a>那么什么是状态？</h4><p>状态在日常生活中很常见，比如看电视时遥控器的按钮对应着暂停和播放，第一次按下按钮暂停，再按下即播放。暂停和播放就是相应的状态。</p><p>最近买了电动牙刷，有这3种状态，开始按下即启动了默认模式 ，再次按下会变成敏感模式， 第三次按下即是关闭状态。如下图所示：</p><p><img src="/images/state1.png"></p><p>采用状态模式实现代码如下：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OffState</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>(toothbrush)&#123;<br>        <span class="hljs-keyword">this</span>.toothbrush = toothbrush;<br>    &#125;<br>    clickButton() &#123;<br>        console.log(<span class="hljs-string">&#x27;电动牙刷启动&#x27;</span>);<br>        <span class="hljs-keyword">this</span>.toothbrush.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">this</span>.toothbrush.onState);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OnState</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>(toothbrush)&#123;<br>        <span class="hljs-keyword">this</span>.toothbrush = toothbrush;<br>    &#125;<br>    clickButton() &#123;<br>        console.log(<span class="hljs-string">&#x27;刷牙模式切换为敏感模式&#x27;</span>);<br>        <span class="hljs-keyword">this</span>.toothbrush.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">this</span>.toothbrush.sensitiveState);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SensitiveState</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>(toothbrush)&#123;<br>        <span class="hljs-keyword">this</span>.toothbrush = toothbrush;<br>    &#125;<br>    clickButton() &#123;<br>        console.log(<span class="hljs-string">&#x27;电动牙刷关闭&#x27;</span>);<br>        <span class="hljs-keyword">this</span>.toothbrush.<span class="hljs-keyword">set</span>(<span class="hljs-keyword">this</span>.toothbrush.offState);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ElecToothbrush</span> </span>&#123;<br>    <span class="hljs-keyword">constructor</span>()&#123;<br>        <span class="hljs-keyword">this</span>.onState = new OnState(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">this</span>.offState = new OffState(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">this</span>.sensitiveState = new SensitiveState(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">this</span>.curState = <span class="hljs-keyword">this</span>.offState;<br>    &#125;<br><br>    <span class="hljs-keyword">set</span>(newState)&#123;<br>        <span class="hljs-keyword">this</span>.curState = newState;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> tb = new ElecToothbrush();<br></code></pre></td></tr></table></figure><p>将tb实例上当前状态的clickButton事件绑定到button上，</p><figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">button</span> <span class="hljs-keyword">onclick</span>=<span class="hljs-string">&quot;tb.curState.clickButton()&quot;</span>&gt;开关&lt;/<span class="hljs-keyword">button</span>&gt;<br><br></code></pre></td></tr></table></figure><p>打开控制台可以看见每按一次button，就会显示相应的状态变化。</p><p>如果不采用状态模式实现，那么在主类toothbrush中会有个click方法在切换对应的状态实现，就像下面这样会有很多if，else语句分支，如果未来再添加新的状态模式，则又需要添加相应的分支，之后该函数会变得越来越大，同时维护麻烦。</p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs pf">if(this.<span class="hljs-keyword">state</span>===&#x27;off&#x27;)&#123;<br>     console.<span class="hljs-keyword">log</span>(&#x27;牙刷启动默认模式&#x27;);<br>     this.<span class="hljs-keyword">state</span>=&#x27;<span class="hljs-keyword">on</span>&#x27;;<br>&#125;else if(this.<span class="hljs-keyword">state</span>===&#x27;<span class="hljs-keyword">on</span>&#x27;)&#123;<br>    console.<span class="hljs-keyword">log</span>(&#x27;sensitive mode&#x27;);<br>    this.<span class="hljs-keyword">state</span>=&#x27;senstive&#x27;;<br>&#125; else if(this.<span class="hljs-keyword">state</span> === &#x27;senstive&#x27;)&#123;<br> console.<span class="hljs-keyword">log</span>(&#x27;off&#x27;);<br>    this.<span class="hljs-keyword">state</span> = &#x27;off&#x27;;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>JS-设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript策略模式</title>
    <link href="/2017/12/21/js-strategy-mode/"/>
    <url>/2017/12/21/js-strategy-mode/</url>
    
    <content type="html"><![CDATA[<h3 id="策略模式："><a href="#策略模式：" class="headerlink" title="策略模式："></a>策略模式：</h3><p>将一些相同的逻辑状态抽离并封装起来，这些逻辑之间的关系是平等的，可替换的。</p><h3 id="什么是策略？"><a href="#什么是策略？" class="headerlink" title="什么是策略？"></a>什么是策略？</h3><p>比如：去某个地方旅游，你可以乘火车，可以乘飞机，也可以乘游轮，那么这些交通工具的选择之间就是某种策略，可以看出这些策略之间是可以相互替换的。</p><h3 id="和状态模式的区别？"><a href="#和状态模式的区别？" class="headerlink" title="和状态模式的区别？"></a>和状态模式的区别？</h3><p>状态模式中每个状态之间其实不是平等的，可替换的，而是相互之间有着联系。</p><p>举例：<br>比如商家为了促销，设置了抽奖，比如抽了一等奖兑换一个iPhone，二等奖兑换吸尘器，三等奖兑换小型烤箱，四等奖兑换电吹风，五等奖兑换毛巾一条。</p><p>如果我们一般正常写这段程序的话，会有很多if，else语句，就像下面这样：</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">if</span>(prize === <span class="hljs-string">&#x27;first&#x27;</span>) &#123;<br>    <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;iphone&#x27;</span>);<br>&#125;<span class="hljs-selector-tag">else</span> <span class="hljs-selector-tag">if</span>(prize === <span class="hljs-string">&#x27;second&#x27;</span>) &#123;<br>    <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;cleaner&#x27;</span>);<br>&#125;<span class="hljs-selector-tag">else</span> <span class="hljs-selector-tag">if</span>(prize === <span class="hljs-string">&#x27;third&#x27;</span>) &#123;<br>    <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;oven&#x27;</span>);<br>&#125;<span class="hljs-selector-tag">else</span> <span class="hljs-selector-tag">if</span>(prize === <span class="hljs-string">&#x27;fourth&#x27;</span>) &#123;<br>    <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;hair drier&#x27;</span>);<br>&#125;<span class="hljs-selector-tag">else</span> <span class="hljs-selector-tag">if</span>(prize ===<span class="hljs-string">&#x27;fifth&#x27;</span>) &#123;<br>    <span class="hljs-selector-tag">console</span><span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;towel&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果采用策略模式，代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstPrize</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">getPrize</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;iphone&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondPrize</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">getPrize</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;cleaner&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThirdPrize</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">getPrize</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;oven&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FourthPrize</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">getPrize</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;hair drier&#x27;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FifthPrize</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">getPrize</span>(<span class="hljs-params"></span>)</span>&#123;<br>     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;towel&#x27;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Prize</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.level = <span class="hljs-literal">null</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">setLevel</span>(<span class="hljs-params">level</span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.level = level;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-title">getPrize</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">this</span>.level.getPrize();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> Prize();<br>p.setLevel(<span class="hljs-keyword">new</span> FirstPrize());<br>p.getPrize(); <span class="hljs-comment">// 输出`iphone`</span><br>p.setLevel(<span class="hljs-keyword">new</span> SecondPrize());<br>p.getPrize(); <span class="hljs-comment">//输出`cleaner`</span><br></code></pre></td></tr></table></figure><p>可以看出，当奖品项增多的时候，只需添加对应的奖品项的类，而无需在主类Prize中添加过多的if，else语句。对各自的逻辑进行了封装，同时符合代码的封闭开放原则。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS-设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript单例模式</title>
    <link href="/2017/12/21/js-single-mode/"/>
    <url>/2017/12/21/js-single-mode/</url>
    
    <content type="html"><![CDATA[<p>单例模式的定义是：保证一个类仅有一个实例，并提供一个全局访问的访问点。</p><span id="more"></span><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一"></a>方法一</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs javascript">  <span class="hljs-keyword">var</span>  Account = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>&#123;<br><br>    <span class="hljs-built_in">this</span>.name = name;<br><br>    <span class="hljs-built_in">this</span>.instance = <span class="hljs-literal">null</span>;<br><br>  &#125;<br><br>  Account.create = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>&#123;<br><br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">this</span>.instance)&#123;<br><br>      <span class="hljs-built_in">this</span>.instance = <span class="hljs-keyword">new</span> Account(name);<br><br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.instance;<br><br>  &#125;<br><br><span class="hljs-keyword">var</span> a = Account.create(<span class="hljs-string">&#x27;a&#x27;</span>);<br><br><span class="hljs-keyword">var</span> b = Account.create(<span class="hljs-string">&#x27;b&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.log(a === b);  <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>不过这个方法有个缺点就是我们通常都是用new 来实例化对象，而这边需用create方法来创建。</p><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h3><p>那我们将代码改进，将实例对象使用new来创建：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span>  Account = ( <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>&#123;<br><br>  <span class="hljs-keyword">var</span> instance = <span class="hljs-literal">null</span>;    <br><br>  <span class="hljs-keyword">var</span> getSingleInstance = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>&#123;<br><br>     <span class="hljs-keyword">if</span>(instance)<br><br>      <span class="hljs-keyword">return</span> instance;<br><br>      <span class="hljs-keyword">return</span> instance = <span class="hljs-keyword">new</span> Acc(name);<br><br>  &#125;<br><br>  <span class="hljs-keyword">var</span>  Acc = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>)</span>&#123;<br><br>    <span class="hljs-built_in">this</span>.name = name;<br><br>  &#125;<br><br> <span class="hljs-keyword">return</span> getSingleInstance;<br><br>&#125;)();<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> Account(<span class="hljs-string">&#x27;a&#x27;</span>);<br><br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> Account(<span class="hljs-string">&#x27;b&#x27;</span>);<br><br><span class="hljs-built_in">console</span>.log(a===b); <span class="hljs-comment">//true</span><br></code></pre></td></tr></table></figure><p>上述代码采用的是闭包的形式来创建单例的，阅读起来相对比较麻烦，并且该函数不能公用。所以可以将创建单例的函数抽出来作为一个公共的function。</p><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h3><p>代码如下：</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs smali">  var  Account = function(name)&#123;<br><br>     this.name = name;<br><br>  &#125;;<br><br>var  createSingleInstance =function (fn)&#123;<br><br>   var<span class="hljs-built_in"> instance </span>;    <br><br> <span class="hljs-built_in"> return </span>function()&#123;<br><br>     if(instance)<br><br>     <span class="hljs-built_in"> return </span>instance;<br><br>   <span class="hljs-built_in"> return </span><span class="hljs-built_in"> instance </span>=<span class="hljs-built_in"> new </span>fn(arguments); //将函数委托给createSingleInstance构造<br><br>  &#125;<br><br>&#125;;<br><br>var getSingle = createSingleInstance(Account);<br><br>var a = getSingle(&#x27;a&#x27;);<br><br>var b = getSingle(&#x27;b&#x27;);<br><br>console.log( b === a);<br></code></pre></td></tr></table></figure><p>总之：单例模式就是类构造出来的实例只有一个。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS-设计模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript 中的 This 指向</title>
    <link href="/2017/12/14/js-this/"/>
    <url>/2017/12/14/js-this/</url>
    
    <content type="html"><![CDATA[<p>由于js是<strong>动态类型</strong>语言，所以this的指向<strong>并不是定义声明</strong>时就确定的，而是在程序<strong>运行时</strong>动态确定的 </p><span id="more"></span><h3 id="作为对象的方法调用："><a href="#作为对象的方法调用：" class="headerlink" title="作为对象的方法调用："></a>作为对象的方法调用：</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">var</span> <span class="hljs-keyword">test</span> = &#123;<br>    aFunc:function() &#123;<br>        console.<span class="hljs-built_in">log</span>(this.b);<br>    &#125;,<br>    b:&#x27;<span class="hljs-keyword">in</span> <span class="hljs-keyword">test</span> func&#x27;<br>&#125;;<br><span class="hljs-keyword">var</span> b = &#x27;<span class="hljs-keyword">out</span> <span class="hljs-keyword">test</span> func&#x27;;<br><span class="hljs-keyword">test</span>.aFunc();<br><br>输出“<span class="hljs-keyword">in</span> <span class="hljs-keyword">test</span> func” ，this指向的是<span class="hljs-keyword">test</span> 对象<br></code></pre></td></tr></table></figure><h3 id="作为普通函数调用"><a href="#作为普通函数调用" class="headerlink" title="作为普通函数调用:"></a>作为普通函数调用:</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span> (<span class="hljs-params"></span>)</span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.b);<br>&#125;<br><span class="hljs-keyword">var</span> b = <span class="hljs-string">&#x27;test&#x27;</span>;<br>test();<br><br>输出“test” 。<span class="hljs-built_in">this</span> 指向的是<span class="hljs-built_in">window</span>对象<br></code></pre></td></tr></table></figure><h3 id="构造器调用"><a href="#构造器调用" class="headerlink" title="构造器调用:"></a>构造器调用:</h3><p>如 函数作为一个构造器使用，</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs haxe"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Test</span></span>(name)&#123;<br>    <span class="hljs-built_in">this</span>.name = name;<br>&#125;<br><span class="hljs-keyword">var</span> <span class="hljs-keyword">new</span><span class="hljs-type">T</span> = <span class="hljs-keyword">new</span> <span class="hljs-type">Test</span>(<span class="hljs-string">&#x27;tt&#x27;</span>);<br>console.log(<span class="hljs-keyword">new</span><span class="hljs-type">T</span>.name);<br><br>输出 <span class="hljs-string">&#x27;tt&#x27;</span>。 <span class="hljs-built_in">this</span> 指向的是新创建的对象，如果构造函数的返回是一个对象，那么<span class="hljs-built_in">this</span>返回该对象，否则返回新创建的对象<br></code></pre></td></tr></table></figure><h3 id="call-或-apply，bind-调用"><a href="#call-或-apply，bind-调用" class="headerlink" title="call 或 apply，bind 调用"></a>call 或 apply，bind 调用</h3><p>call， apply ，bind都可以改变运行时this的指向。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> test1 = &#123;<br>    <span class="hljs-attr">aFunc</span>:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<br>        <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>.name);<br>    &#125;,<br>    <span class="hljs-attr">name</span>:<span class="hljs-string">&#x27;test1&#x27;</span><br>&#125;<br><span class="hljs-keyword">var</span> test2 =&#123;<br>    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;test2&quot;</span><br>&#125;;<br>test1.aFunc.apply(test2); <span class="hljs-comment">//或者test1.aFunc.bind(test2)();</span><br><br>输出<span class="hljs-string">&#x27;test2&#x27;</span> 。<span class="hljs-built_in">this</span>指向的是 test2 对象。<br></code></pre></td></tr></table></figure><p>call和apply没什么区别，只是传入的参数不一样，call传入的第一个参数是this的指向，从第二个参数开始一个个传入function中，<br>而apply第二个参数是function接受的参数的数组，如果传入的第一个参数为 null，this 会指向默认的宿主对象，浏览器中为window。</p>]]></content>
    
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
